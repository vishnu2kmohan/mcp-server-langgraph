/*
MCP Server with LangGraph

AI Agent with fine-grained authorization and observability - StreamableHTTP transport

API version: 2.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mcpclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SCIM20APIService SCIM20API service
type SCIM20APIService service

type ApiCreateGroupScimV2GroupsPostRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	bodyCreateGroupScimV2GroupsPost *BodyCreateGroupScimV2GroupsPost
}

func (r ApiCreateGroupScimV2GroupsPostRequest) BodyCreateGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost BodyCreateGroupScimV2GroupsPost) ApiCreateGroupScimV2GroupsPostRequest {
	r.bodyCreateGroupScimV2GroupsPost = &bodyCreateGroupScimV2GroupsPost
	return r
}

func (r ApiCreateGroupScimV2GroupsPostRequest) Execute() (*SCIMGroup, *http.Response, error) {
	return r.ApiService.CreateGroupScimV2GroupsPostExecute(r)
}

/*
CreateGroupScimV2GroupsPost Create Group

Create a new group (SCIM 2.0)

Example:
    ```json
    {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
        "displayName": "Engineering",
        "members": [
            {"value": "user-id-123", "display": "Alice Smith"}
        ]
    }
    ```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGroupScimV2GroupsPostRequest
*/
func (a *SCIM20APIService) CreateGroupScimV2GroupsPost(ctx context.Context) ApiCreateGroupScimV2GroupsPostRequest {
	return ApiCreateGroupScimV2GroupsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SCIMGroup
func (a *SCIM20APIService) CreateGroupScimV2GroupsPostExecute(r ApiCreateGroupScimV2GroupsPostRequest) (*SCIMGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.CreateGroupScimV2GroupsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyCreateGroupScimV2GroupsPost == nil {
		return localVarReturnValue, nil, reportError("bodyCreateGroupScimV2GroupsPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyCreateGroupScimV2GroupsPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserScimV2UsersPostRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	bodyCreateUserScimV2UsersPost *BodyCreateUserScimV2UsersPost
}

func (r ApiCreateUserScimV2UsersPostRequest) BodyCreateUserScimV2UsersPost(bodyCreateUserScimV2UsersPost BodyCreateUserScimV2UsersPost) ApiCreateUserScimV2UsersPostRequest {
	r.bodyCreateUserScimV2UsersPost = &bodyCreateUserScimV2UsersPost
	return r
}

func (r ApiCreateUserScimV2UsersPostRequest) Execute() (*SCIMUser, *http.Response, error) {
	return r.ApiService.CreateUserScimV2UsersPostExecute(r)
}

/*
CreateUserScimV2UsersPost Create User

Create a new user (SCIM 2.0)

Provisions user in Keycloak and syncs roles to OpenFGA.

Example:
    ```json
    {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@example.com",
        "name": {
            "givenName": "Alice",
            "familyName": "Smith"
        },
        "emails": [{
            "value": "alice@example.com",
            "primary": true
        }],
        "active": true
    }
    ```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateUserScimV2UsersPostRequest
*/
func (a *SCIM20APIService) CreateUserScimV2UsersPost(ctx context.Context) ApiCreateUserScimV2UsersPostRequest {
	return ApiCreateUserScimV2UsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SCIMUser
func (a *SCIM20APIService) CreateUserScimV2UsersPostExecute(r ApiCreateUserScimV2UsersPostRequest) (*SCIMUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.CreateUserScimV2UsersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyCreateUserScimV2UsersPost == nil {
		return localVarReturnValue, nil, reportError("bodyCreateUserScimV2UsersPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyCreateUserScimV2UsersPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserScimV2UsersUserIdDeleteRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	userId string
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

func (r ApiDeleteUserScimV2UsersUserIdDeleteRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiDeleteUserScimV2UsersUserIdDeleteRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiDeleteUserScimV2UsersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserScimV2UsersUserIdDeleteExecute(r)
}

/*
DeleteUserScimV2UsersUserIdDelete Delete User

Delete (deactivate) user (SCIM 2.0)

Deactivates user in Keycloak and removes OpenFGA tuples.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return ApiDeleteUserScimV2UsersUserIdDeleteRequest
*/
func (a *SCIM20APIService) DeleteUserScimV2UsersUserIdDelete(ctx context.Context, userId string) ApiDeleteUserScimV2UsersUserIdDeleteRequest {
	return ApiDeleteUserScimV2UsersUserIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *SCIM20APIService) DeleteUserScimV2UsersUserIdDeleteExecute(r ApiDeleteUserScimV2UsersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.DeleteUserScimV2UsersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGroupScimV2GroupsGroupIdGetRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	groupId string
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

func (r ApiGetGroupScimV2GroupsGroupIdGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiGetGroupScimV2GroupsGroupIdGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiGetGroupScimV2GroupsGroupIdGetRequest) Execute() (*SCIMGroup, *http.Response, error) {
	return r.ApiService.GetGroupScimV2GroupsGroupIdGetExecute(r)
}

/*
GetGroupScimV2GroupsGroupIdGet Get Group

Get group by ID (SCIM 2.0)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetGroupScimV2GroupsGroupIdGetRequest
*/
func (a *SCIM20APIService) GetGroupScimV2GroupsGroupIdGet(ctx context.Context, groupId string) ApiGetGroupScimV2GroupsGroupIdGetRequest {
	return ApiGetGroupScimV2GroupsGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return SCIMGroup
func (a *SCIM20APIService) GetGroupScimV2GroupsGroupIdGetExecute(r ApiGetGroupScimV2GroupsGroupIdGetRequest) (*SCIMGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.GetGroupScimV2GroupsGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserScimV2UsersUserIdGetRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	userId string
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

func (r ApiGetUserScimV2UsersUserIdGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiGetUserScimV2UsersUserIdGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiGetUserScimV2UsersUserIdGetRequest) Execute() (*SCIMUser, *http.Response, error) {
	return r.ApiService.GetUserScimV2UsersUserIdGetExecute(r)
}

/*
GetUserScimV2UsersUserIdGet Get User

Get user by ID (SCIM 2.0)

Returns user in SCIM format.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return ApiGetUserScimV2UsersUserIdGetRequest
*/
func (a *SCIM20APIService) GetUserScimV2UsersUserIdGet(ctx context.Context, userId string) ApiGetUserScimV2UsersUserIdGetRequest {
	return ApiGetUserScimV2UsersUserIdGetRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return SCIMUser
func (a *SCIM20APIService) GetUserScimV2UsersUserIdGetExecute(r ApiGetUserScimV2UsersUserIdGetRequest) (*SCIMUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.GetUserScimV2UsersUserIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsersScimV2UsersGetRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	filter *string
	startIndex *int32
	count *int32
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

// SCIM filter expression
func (r ApiListUsersScimV2UsersGetRequest) Filter(filter string) ApiListUsersScimV2UsersGetRequest {
	r.filter = &filter
	return r
}

// 1-based start index
func (r ApiListUsersScimV2UsersGetRequest) StartIndex(startIndex int32) ApiListUsersScimV2UsersGetRequest {
	r.startIndex = &startIndex
	return r
}

// Number of results
func (r ApiListUsersScimV2UsersGetRequest) Count(count int32) ApiListUsersScimV2UsersGetRequest {
	r.count = &count
	return r
}

func (r ApiListUsersScimV2UsersGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiListUsersScimV2UsersGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiListUsersScimV2UsersGetRequest) Execute() (*SCIMListResponse, *http.Response, error) {
	return r.ApiService.ListUsersScimV2UsersGetExecute(r)
}

/*
ListUsersScimV2UsersGet List Users

List/search users (SCIM 2.0)

Supports basic filtering (e.g., 'userName eq "alice@example.com"').

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUsersScimV2UsersGetRequest
*/
func (a *SCIM20APIService) ListUsersScimV2UsersGet(ctx context.Context) ApiListUsersScimV2UsersGetRequest {
	return ApiListUsersScimV2UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SCIMListResponse
func (a *SCIM20APIService) ListUsersScimV2UsersGetExecute(r ApiListUsersScimV2UsersGetRequest) (*SCIMListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.ListUsersScimV2UsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	} else {
        var defaultValue int32 = 1
        parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", defaultValue, "form", "")
        r.startIndex = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
        var defaultValue int32 = 100
        parameterAddToHeaderOrQuery(localVarQueryParams, "count", defaultValue, "form", "")
        r.count = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceUserScimV2UsersUserIdPutRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	userId string
	bodyReplaceUserScimV2UsersUserIdPut *BodyReplaceUserScimV2UsersUserIdPut
}

func (r ApiReplaceUserScimV2UsersUserIdPutRequest) BodyReplaceUserScimV2UsersUserIdPut(bodyReplaceUserScimV2UsersUserIdPut BodyReplaceUserScimV2UsersUserIdPut) ApiReplaceUserScimV2UsersUserIdPutRequest {
	r.bodyReplaceUserScimV2UsersUserIdPut = &bodyReplaceUserScimV2UsersUserIdPut
	return r
}

func (r ApiReplaceUserScimV2UsersUserIdPutRequest) Execute() (*SCIMUser, *http.Response, error) {
	return r.ApiService.ReplaceUserScimV2UsersUserIdPutExecute(r)
}

/*
ReplaceUserScimV2UsersUserIdPut Replace User

Replace user (SCIM 2.0 PUT)

Replaces entire user resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return ApiReplaceUserScimV2UsersUserIdPutRequest
*/
func (a *SCIM20APIService) ReplaceUserScimV2UsersUserIdPut(ctx context.Context, userId string) ApiReplaceUserScimV2UsersUserIdPutRequest {
	return ApiReplaceUserScimV2UsersUserIdPutRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return SCIMUser
func (a *SCIM20APIService) ReplaceUserScimV2UsersUserIdPutExecute(r ApiReplaceUserScimV2UsersUserIdPutRequest) (*SCIMUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.ReplaceUserScimV2UsersUserIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyReplaceUserScimV2UsersUserIdPut == nil {
		return localVarReturnValue, nil, reportError("bodyReplaceUserScimV2UsersUserIdPut is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyReplaceUserScimV2UsersUserIdPut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserScimV2UsersUserIdPatchRequest struct {
	ctx context.Context
	ApiService *SCIM20APIService
	userId string
	bodyUpdateUserScimV2UsersUserIdPatch *BodyUpdateUserScimV2UsersUserIdPatch
}

func (r ApiUpdateUserScimV2UsersUserIdPatchRequest) BodyUpdateUserScimV2UsersUserIdPatch(bodyUpdateUserScimV2UsersUserIdPatch BodyUpdateUserScimV2UsersUserIdPatch) ApiUpdateUserScimV2UsersUserIdPatchRequest {
	r.bodyUpdateUserScimV2UsersUserIdPatch = &bodyUpdateUserScimV2UsersUserIdPatch
	return r
}

func (r ApiUpdateUserScimV2UsersUserIdPatchRequest) Execute() (*SCIMUser, *http.Response, error) {
	return r.ApiService.UpdateUserScimV2UsersUserIdPatchExecute(r)
}

/*
UpdateUserScimV2UsersUserIdPatch Update User

Update user with PATCH operations (SCIM 2.0)

Supports add, remove, replace operations.

Example:
    ```json
    {
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
        "Operations": [
            {
                "op": "replace",
                "path": "active",
                "value": false
            }
        ]
    }
    ```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return ApiUpdateUserScimV2UsersUserIdPatchRequest
*/
func (a *SCIM20APIService) UpdateUserScimV2UsersUserIdPatch(ctx context.Context, userId string) ApiUpdateUserScimV2UsersUserIdPatchRequest {
	return ApiUpdateUserScimV2UsersUserIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return SCIMUser
func (a *SCIM20APIService) UpdateUserScimV2UsersUserIdPatchExecute(r ApiUpdateUserScimV2UsersUserIdPatchRequest) (*SCIMUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SCIMUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SCIM20APIService.UpdateUserScimV2UsersUserIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyUpdateUserScimV2UsersUserIdPatch == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateUserScimV2UsersUserIdPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyUpdateUserScimV2UsersUserIdPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
