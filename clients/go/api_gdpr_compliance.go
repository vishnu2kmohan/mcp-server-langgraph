/*
MCP Server with LangGraph

AI Agent with fine-grained authorization and observability - StreamableHTTP transport

API version: 2.8.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mcpclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// GDPRComplianceAPIService GDPRComplianceAPI service
type GDPRComplianceAPIService service

type ApiDeleteUserAccountApiV1UsersMeDeleteRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	confirm *bool
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

// Must be true to confirm account deletion
func (r ApiDeleteUserAccountApiV1UsersMeDeleteRequest) Confirm(confirm bool) ApiDeleteUserAccountApiV1UsersMeDeleteRequest {
	r.confirm = &confirm
	return r
}

func (r ApiDeleteUserAccountApiV1UsersMeDeleteRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiDeleteUserAccountApiV1UsersMeDeleteRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiDeleteUserAccountApiV1UsersMeDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteUserAccountApiV1UsersMeDeleteExecute(r)
}

/*
DeleteUserAccountApiV1UsersMeDelete Delete User Account

Delete user account and all data (GDPR Article 17 - Right to Erasure)

**WARNING**: This is an irreversible operation that permanently deletes all user data.

**GDPR Article 17**: The data subject shall have the right to obtain from the
controller the erasure of personal data concerning him or her without undue delay.

**Query Parameters**:
- `confirm`: Must be set to `true` to confirm deletion

**What gets deleted**:
- User profile and account
- All sessions
- All conversations and messages
- All preferences and settings
- All authorization tuples

**What gets anonymized** (retained for compliance):
- Audit logs (user_id replaced with hash)

**Response**: Deletion result with details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteUserAccountApiV1UsersMeDeleteRequest
*/
func (a *GDPRComplianceAPIService) DeleteUserAccountApiV1UsersMeDelete(ctx context.Context) ApiDeleteUserAccountApiV1UsersMeDeleteRequest {
	return ApiDeleteUserAccountApiV1UsersMeDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GDPRComplianceAPIService) DeleteUserAccountApiV1UsersMeDeleteExecute(r ApiDeleteUserAccountApiV1UsersMeDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.DeleteUserAccountApiV1UsersMeDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.confirm == nil {
		return localVarReturnValue, nil, reportError("confirm is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "confirm", r.confirm, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExportUserDataApiV1UsersMeExportGetRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	format *string
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

// Export format: json or csv
func (r ApiExportUserDataApiV1UsersMeExportGetRequest) Format(format string) ApiExportUserDataApiV1UsersMeExportGetRequest {
	r.format = &format
	return r
}

func (r ApiExportUserDataApiV1UsersMeExportGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiExportUserDataApiV1UsersMeExportGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiExportUserDataApiV1UsersMeExportGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ExportUserDataApiV1UsersMeExportGetExecute(r)
}

/*
ExportUserDataApiV1UsersMeExportGet Export User Data

Export user data in portable format (GDPR Article 20 - Right to Data Portability)

**GDPR Article 20**: The data subject shall have the right to receive the personal
data concerning him or her in a structured, commonly used and machine-readable format.

**Query Parameters**:
- `format`: Export format (json or csv)

**Response**: File download in requested format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExportUserDataApiV1UsersMeExportGetRequest
*/
func (a *GDPRComplianceAPIService) ExportUserDataApiV1UsersMeExportGet(ctx context.Context) ApiExportUserDataApiV1UsersMeExportGetRequest {
	return ApiExportUserDataApiV1UsersMeExportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *GDPRComplianceAPIService) ExportUserDataApiV1UsersMeExportGetExecute(r ApiExportUserDataApiV1UsersMeExportGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.ExportUserDataApiV1UsersMeExportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	} else {
        var defaultValue string = "json"
        parameterAddToHeaderOrQuery(localVarQueryParams, "format", defaultValue, "form", "")
        r.format = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConsentStatusApiV1UsersMeConsentGetRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

func (r ApiGetConsentStatusApiV1UsersMeConsentGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiGetConsentStatusApiV1UsersMeConsentGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiGetConsentStatusApiV1UsersMeConsentGetRequest) Execute() (*ConsentResponse, *http.Response, error) {
	return r.ApiService.GetConsentStatusApiV1UsersMeConsentGetExecute(r)
}

/*
GetConsentStatusApiV1UsersMeConsentGet Get Consent Status

Get current consent status (GDPR Article 21 - Right to Object)

Returns all consent preferences for the authenticated user.

**Response**: Current consent status for all consent types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConsentStatusApiV1UsersMeConsentGetRequest
*/
func (a *GDPRComplianceAPIService) GetConsentStatusApiV1UsersMeConsentGet(ctx context.Context) ApiGetConsentStatusApiV1UsersMeConsentGetRequest {
	return ApiGetConsentStatusApiV1UsersMeConsentGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsentResponse
func (a *GDPRComplianceAPIService) GetConsentStatusApiV1UsersMeConsentGetExecute(r ApiGetConsentStatusApiV1UsersMeConsentGetRequest) (*ConsentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.GetConsentStatusApiV1UsersMeConsentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me/consent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserDataApiV1UsersMeDataGetRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	hTTPAuthorizationCredentials *HTTPAuthorizationCredentials
}

func (r ApiGetUserDataApiV1UsersMeDataGetRequest) HTTPAuthorizationCredentials(hTTPAuthorizationCredentials HTTPAuthorizationCredentials) ApiGetUserDataApiV1UsersMeDataGetRequest {
	r.hTTPAuthorizationCredentials = &hTTPAuthorizationCredentials
	return r
}

func (r ApiGetUserDataApiV1UsersMeDataGetRequest) Execute() (*UserDataExport, *http.Response, error) {
	return r.ApiService.GetUserDataApiV1UsersMeDataGetExecute(r)
}

/*
GetUserDataApiV1UsersMeDataGet Get User Data

Export all user data (GDPR Article 15 - Right to Access)

Returns all personal data associated with the authenticated user.

**GDPR Article 15**: The data subject shall have the right to obtain from the
controller confirmation as to whether or not personal data concerning him or
her are being processed, and access to the personal data.

**Response**: Complete JSON export of all user data including:
- User profile
- Sessions
- Conversations
- Preferences
- Audit log
- Consents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserDataApiV1UsersMeDataGetRequest
*/
func (a *GDPRComplianceAPIService) GetUserDataApiV1UsersMeDataGet(ctx context.Context) ApiGetUserDataApiV1UsersMeDataGetRequest {
	return ApiGetUserDataApiV1UsersMeDataGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserDataExport
func (a *GDPRComplianceAPIService) GetUserDataApiV1UsersMeDataGetExecute(r ApiGetUserDataApiV1UsersMeDataGetRequest) (*UserDataExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDataExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.GetUserDataApiV1UsersMeDataGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me/data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hTTPAuthorizationCredentials
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConsentApiV1UsersMeConsentPostRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	bodyUpdateConsentApiV1UsersMeConsentPost *BodyUpdateConsentApiV1UsersMeConsentPost
}

func (r ApiUpdateConsentApiV1UsersMeConsentPostRequest) BodyUpdateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost BodyUpdateConsentApiV1UsersMeConsentPost) ApiUpdateConsentApiV1UsersMeConsentPostRequest {
	r.bodyUpdateConsentApiV1UsersMeConsentPost = &bodyUpdateConsentApiV1UsersMeConsentPost
	return r
}

func (r ApiUpdateConsentApiV1UsersMeConsentPostRequest) Execute() (*ConsentResponse, *http.Response, error) {
	return r.ApiService.UpdateConsentApiV1UsersMeConsentPostExecute(r)
}

/*
UpdateConsentApiV1UsersMeConsentPost Update Consent

Update user consent preferences (GDPR Article 21 - Right to Object)

**GDPR Article 21**: The data subject shall have the right to object at any time
to processing of personal data concerning him or her.

**Request Body**: Consent type and whether it's granted

**Response**: Current consent status for all types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateConsentApiV1UsersMeConsentPostRequest
*/
func (a *GDPRComplianceAPIService) UpdateConsentApiV1UsersMeConsentPost(ctx context.Context) ApiUpdateConsentApiV1UsersMeConsentPostRequest {
	return ApiUpdateConsentApiV1UsersMeConsentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConsentResponse
func (a *GDPRComplianceAPIService) UpdateConsentApiV1UsersMeConsentPostExecute(r ApiUpdateConsentApiV1UsersMeConsentPostRequest) (*ConsentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConsentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.UpdateConsentApiV1UsersMeConsentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me/consent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyUpdateConsentApiV1UsersMeConsentPost == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateConsentApiV1UsersMeConsentPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyUpdateConsentApiV1UsersMeConsentPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateUserProfileApiV1UsersMePatchRequest struct {
	ctx context.Context
	ApiService *GDPRComplianceAPIService
	bodyUpdateUserProfileApiV1UsersMePatch *BodyUpdateUserProfileApiV1UsersMePatch
}

func (r ApiUpdateUserProfileApiV1UsersMePatchRequest) BodyUpdateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch BodyUpdateUserProfileApiV1UsersMePatch) ApiUpdateUserProfileApiV1UsersMePatchRequest {
	r.bodyUpdateUserProfileApiV1UsersMePatch = &bodyUpdateUserProfileApiV1UsersMePatch
	return r
}

func (r ApiUpdateUserProfileApiV1UsersMePatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateUserProfileApiV1UsersMePatchExecute(r)
}

/*
UpdateUserProfileApiV1UsersMePatch Update User Profile

Update user profile (GDPR Article 16 - Right to Rectification)

**GDPR Article 16**: The data subject shall have the right to obtain from the
controller without undue delay the rectification of inaccurate personal data
concerning him or her.

**Request Body**: Profile fields to update (only provided fields are updated)

**Response**: Updated user profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateUserProfileApiV1UsersMePatchRequest
*/
func (a *GDPRComplianceAPIService) UpdateUserProfileApiV1UsersMePatch(ctx context.Context) ApiUpdateUserProfileApiV1UsersMePatchRequest {
	return ApiUpdateUserProfileApiV1UsersMePatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *GDPRComplianceAPIService) UpdateUserProfileApiV1UsersMePatchExecute(r ApiUpdateUserProfileApiV1UsersMePatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GDPRComplianceAPIService.UpdateUserProfileApiV1UsersMePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyUpdateUserProfileApiV1UsersMePatch == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateUserProfileApiV1UsersMePatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyUpdateUserProfileApiV1UsersMePatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
