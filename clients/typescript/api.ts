/* tslint:disable */
/* eslint-disable */
/**
 * MCP Server with LangGraph
 * AI Agent with fine-grained authorization and observability - StreamableHTTP transport
 *
 * The version of the OpenAPI document: 2.8.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response containing API key metadata
 */
export interface APIKeyResponse {
    'key_id': string;
    'name': string;
    'created': string;
    'expires_at': string;
    'last_used'?: string | null;
}
/**
 * API version metadata  Follows semantic versioning (MAJOR.MINOR.PATCH): - MAJOR: Breaking changes (incompatible API changes) - MINOR: New features (backward-compatible) - PATCH: Bug fixes (backward-compatible)
 */
export interface APIVersionInfo {
    /**
     * Application version (semantic versioning: MAJOR.MINOR.PATCH)
     */
    'version': string;
    /**
     * Current API version (e.g., \'v1\')
     */
    'api_version': string;
    /**
     * List of supported API versions
     */
    'supported_versions': Array<string>;
    /**
     * List of deprecated API versions (still functional but will be removed)
     */
    'deprecated_versions'?: Array<string>;
    /**
     * Sunset dates for deprecated versions (ISO 8601 format)
     */
    'sunset_dates'?: { [key: string]: string; };
    'changelog_url'?: string | null;
    'documentation_url'?: string | null;
}
export interface BodyCreateApiKeyApiV1ApiKeysPost {
    'request': CreateAPIKeyRequest;
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyCreateGroupScimV2GroupsPost {
    'group_data': { [key: string]: any; };
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyCreateServicePrincipalApiV1ServicePrincipalsPost {
    'request': CreateServicePrincipalRequest;
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyCreateUserScimV2UsersPost {
    'user_data': { [key: string]: any; };
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyReplaceUserScimV2UsersUserIdPut {
    'user_data': { [key: string]: any; };
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyUpdateConsentApiV1UsersMeConsentPost {
    'consent': ConsentRecord;
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyUpdateUserProfileApiV1UsersMePatch {
    'profile_update': UserProfileUpdate;
    'credentials'?: HTTPAuthorizationCredentials | null;
}
export interface BodyUpdateUserScimV2UsersUserIdPatch {
    'patch_request': SCIMPatchRequest;
    'credentials'?: HTTPAuthorizationCredentials | null;
}
/**
 * Consent record for GDPR Article 21
 */
export interface ConsentRecord {
    /**
     * Type of consent
     */
    'consent_type': ConsentType;
    /**
     * Whether consent is granted
     */
    'granted': boolean;
    'timestamp'?: string | null;
    'ip_address'?: string | null;
    'user_agent'?: string | null;
}


/**
 * Response for consent operations
 */
export interface ConsentResponse {
    'user_id': string;
    /**
     * Current consent status for all types
     */
    'consents': { [key: string]: { [key: string]: any; }; };
}
/**
 * Types of consent that can be granted or revoked
 */

export const ConsentType = {
    Analytics: 'analytics',
    Marketing: 'marketing',
    ThirdParty: 'third_party',
    Profiling: 'profiling'
} as const;

export type ConsentType = typeof ConsentType[keyof typeof ConsentType];


/**
 * Request to create a new API key
 */
export interface CreateAPIKeyRequest {
    /**
     * Human-readable name for the API key
     */
    'name': string;
    /**
     * Days until expiration (default: 365)
     */
    'expires_days'?: number;
}
/**
 * Response when creating API key (includes the key itself)
 */
export interface CreateAPIKeyResponse {
    'key_id': string;
    'name': string;
    'created': string;
    'expires_at': string;
    'last_used'?: string | null;
    /**
     * API key (save securely, won\'t be shown again)
     */
    'api_key': string;
    'message'?: string;
}
/**
 * Request to create a new service principal
 */
export interface CreateServicePrincipalRequest {
    /**
     * Human-readable name for the service
     */
    'name': string;
    /**
     * Purpose/description of the service
     */
    'description': string;
    /**
     * Authentication mode: \'client_credentials\' or \'service_account_user\'
     */
    'authentication_mode'?: string;
    'associated_user_id'?: string | null;
    /**
     * Whether to inherit permissions from associated user
     */
    'inherit_permissions'?: boolean;
}
/**
 * Response when creating service principal (includes secret)
 */
export interface CreateServicePrincipalResponse {
    'service_id': string;
    'name': string;
    'description': string;
    'authentication_mode': string;
    'associated_user_id': string | null;
    'owner_user_id': string | null;
    'inherit_permissions': boolean;
    'enabled': boolean;
    'created_at': string | null;
    /**
     * Client secret (save securely, won\'t be shown again)
     */
    'client_secret': string;
    'message'?: string;
}
/**
 * The HTTP authorization credentials in the result of using `HTTPBearer` or `HTTPDigest` in a dependency.  The HTTP authorization header value is split by the first space.  The first part is the `scheme`, the second part is the `credentials`.  For example, in an HTTP Bearer token scheme, the client will send a header like:  ``` Authorization: Bearer deadbeef12346 ```  In this case:  * `scheme` will have the value `\"Bearer\"` * `credentials` will have the value `\"deadbeef12346\"`
 */
export interface HTTPAuthorizationCredentials {
    'scheme': string;
    'credentials': string;
}
export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
/**
 * Login request with username and password
 */
export interface LoginRequest {
    /**
     * Username
     */
    'username': string;
    /**
     * Password
     */
    'password': string;
}
/**
 * Login response with JWT token
 */
export interface LoginResponse {
    /**
     * JWT access token
     */
    'access_token': string;
    /**
     * Token type (always \'bearer\')
     */
    'token_type'?: string;
    /**
     * Token expiration in seconds
     */
    'expires_in': number;
    /**
     * User identifier
     */
    'user_id': string;
    /**
     * Username
     */
    'username': string;
    /**
     * User roles
     */
    'roles': Array<string>;
}
/**
 * Token refresh request
 */
export interface RefreshTokenRequest {
    'refresh_token'?: string | null;
    'current_token'?: string | null;
}
/**
 * Token refresh response
 */
export interface RefreshTokenResponse {
    /**
     * New JWT access token
     */
    'access_token': string;
    /**
     * Token type
     */
    'token_type'?: string;
    /**
     * Token expiration in seconds
     */
    'expires_in': number;
    'refresh_token'?: string | null;
}
/**
 * Response when rotating API key
 */
export interface RotateAPIKeyResponse {
    'key_id': string;
    /**
     * New API key
     */
    'new_api_key': string;
    'message'?: string;
}
/**
 * Response when rotating service principal secret
 */
export interface RotateSecretResponse {
    'service_id': string;
    /**
     * New client secret
     */
    'client_secret': string;
    'message'?: string;
}
/**
 * SCIM address
 */
export interface SCIMAddress {
    'formatted'?: string | null;
    'streetAddress'?: string | null;
    'locality'?: string | null;
    'region'?: string | null;
    'postalCode'?: string | null;
    'country'?: string | null;
    'type'?: string | null;
    'primary'?: boolean;
}
/**
 * SCIM email address
 */
export interface SCIMEmail {
    'value': string;
    'type'?: string | null;
    'primary'?: boolean;
}
/**
 * SCIM Enterprise User Extension (RFC 7643 Section 4.3)
 */
export interface SCIMEnterpriseUser {
    'employeeNumber'?: string | null;
    'costCenter'?: string | null;
    'organization'?: string | null;
    'division'?: string | null;
    'department'?: string | null;
    'manager'?: { [key: string]: string; } | null;
}
/**
 * SCIM 2.0 Group Resource
 */
export interface SCIMGroup {
    'schemas'?: Array<string | null>;
    'id'?: string | null;
    'displayName': string;
    'members'?: Array<SCIMMember>;
    'meta'?: { [key: string]: any; } | null;
}
/**
 * SCIM group membership
 */
export interface SCIMGroupMembership {
    'value': string;
    'ref'?: string | null;
    'display'?: string | null;
    'type'?: string | null;
}
/**
 * SCIM List Response
 */
export interface SCIMListResponse {
    'schemas'?: Array<string>;
    'totalResults': number;
    'startIndex'?: number;
    'itemsPerPage': number;
    'Resources': Array<any>;
}
/**
 * SCIM group member
 */
export interface SCIMMember {
    'value': string;
    'ref'?: string | null;
    'display'?: string | null;
    'type'?: string | null;
}
/**
 * SCIM user name
 */
export interface SCIMName {
    'formatted'?: string | null;
    'familyName'?: string | null;
    'givenName'?: string | null;
    'middleName'?: string | null;
    'honorificPrefix'?: string | null;
    'honorificSuffix'?: string | null;
}
/**
 * SCIM PATCH operation types
 */

export const SCIMPatchOp = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace'
} as const;

export type SCIMPatchOp = typeof SCIMPatchOp[keyof typeof SCIMPatchOp];


/**
 * SCIM PATCH operation
 */
export interface SCIMPatchOperation {
    'op': SCIMPatchOp;
    'path'?: string | null;
    'value'?: any;
}


/**
 * SCIM PATCH request
 */
export interface SCIMPatchRequest {
    'schemas'?: Array<string>;
    'Operations': Array<SCIMPatchOperation>;
}
/**
 * SCIM phone number
 */
export interface SCIMPhoneNumber {
    'value': string;
    'type'?: string | null;
    'primary'?: boolean;
}
/**
 * SCIM 2.0 User Resource  Core schema with optional Enterprise extension.
 */
export interface SCIMUser {
    'schemas'?: Array<string | null>;
    'id'?: string | null;
    'externalId'?: string | null;
    'userName': string;
    'name'?: SCIMName | null;
    'displayName'?: string | null;
    'nickName'?: string | null;
    'profileUrl'?: string | null;
    'title'?: string | null;
    'userType'?: string | null;
    'preferredLanguage'?: string | null;
    'locale'?: string | null;
    'timezone'?: string | null;
    'active'?: boolean;
    'password'?: string | null;
    'emails'?: Array<SCIMEmail>;
    'phoneNumbers'?: Array<SCIMPhoneNumber>;
    'addresses'?: Array<SCIMAddress>;
    'groups'?: Array<SCIMGroupMembership>;
    'meta'?: { [key: string]: any; } | null;
    'urn:ietf:params:scim:schemas:extension:enterprise:2.0:User'?: SCIMEnterpriseUser | null;
}
/**
 * Response containing service principal details
 */
export interface ServicePrincipalResponse {
    'service_id': string;
    'name': string;
    'description': string;
    'authentication_mode': string;
    'associated_user_id': string | null;
    'owner_user_id': string | null;
    'inherit_permissions': boolean;
    'enabled': boolean;
    'created_at': string | null;
}
/**
 * Complete user data export for GDPR compliance  Includes all personal data associated with a user.
 */
export interface UserDataExport {
    /**
     * Unique export identifier
     */
    'export_id': string;
    /**
     * ISO timestamp of export
     */
    'export_timestamp': string;
    /**
     * User identifier
     */
    'user_id': string;
    /**
     * Username
     */
    'username': string;
    /**
     * User email address
     */
    'email': string;
    /**
     * User profile data
     */
    'profile'?: { [key: string]: any; };
    /**
     * Active and recent sessions
     */
    'sessions'?: Array<{ [key: string]: any; } | null>;
    /**
     * Conversation history
     */
    'conversations'?: Array<{ [key: string]: any; } | null>;
    /**
     * User preferences and settings
     */
    'preferences'?: { [key: string]: any; };
    /**
     * User activity audit log
     */
    'audit_log'?: Array<{ [key: string]: any; } | null>;
    /**
     * Consent records
     */
    'consents'?: Array<{ [key: string]: any; } | null>;
    /**
     * Additional metadata
     */
    'metadata'?: { [key: string]: any; };
}
/**
 * User profile update model (GDPR Article 16 - Right to Rectification)
 */
export interface UserProfileUpdate {
    'name'?: string | null;
    'email'?: string | null;
    'preferences'?: { [key: string]: any; } | null;
}
export interface ValidationError {
    'loc': Array<ValidationErrorLocInner>;
    'msg': string;
    'type': string;
}
export interface ValidationErrorLocInner {
}

/**
 * APIKeysApi - axios parameter creator
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API key for the current user  Creates a cryptographically secure API key with bcrypt hashing. **Save the returned api_key securely** - it will not be shown again.  Maximum 5 keys per user. Revoke an existing key before creating more.  Example:     ```json     {         \"name\": \"Production API Key\",         \"expires_days\": 365     }     ```
         * @summary Create Api Key
         * @param {BodyCreateApiKeyApiV1ApiKeysPost} bodyCreateApiKeyApiV1ApiKeysPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyApiV1ApiKeysPost: async (bodyCreateApiKeyApiV1ApiKeysPost: BodyCreateApiKeyApiV1ApiKeysPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateApiKeyApiV1ApiKeysPost' is not null or undefined
            assertParamExists('createApiKeyApiV1ApiKeysPost', 'bodyCreateApiKeyApiV1ApiKeysPost', bodyCreateApiKeyApiV1ApiKeysPost)
            const localVarPath = `/api/v1/api-keys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateApiKeyApiV1ApiKeysPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all API keys for the current user  Returns metadata for all keys (name, created, expires, last_used). Does not include the actual API keys.
         * @summary List Api Keys
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysApiV1ApiKeysGet: async (hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/api-keys/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an API key  Permanently deletes the API key. This action cannot be undone. Any clients using this key will immediately lose access.
         * @summary Revoke Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyApiV1ApiKeysKeyIdDelete: async (keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('revokeApiKeyApiV1ApiKeysKeyIdDelete', 'keyId', keyId)
            const localVarPath = `/api/v1/api-keys/{key_id}`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotate an API key  Generates a new API key while keeping the same key_id. The old key is invalidated immediately.  **Save the new_api_key securely** - update your client configuration.
         * @summary Rotate Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiKeyApiV1ApiKeysKeyIdRotatePost: async (keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('rotateApiKeyApiV1ApiKeysKeyIdRotatePost', 'keyId', keyId)
            const localVarPath = `/api/v1/api-keys/{key_id}/rotate`
                .replace(`{${"key_id"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new API key for the current user  Creates a cryptographically secure API key with bcrypt hashing. **Save the returned api_key securely** - it will not be shown again.  Maximum 5 keys per user. Revoke an existing key before creating more.  Example:     ```json     {         \"name\": \"Production API Key\",         \"expires_days\": 365     }     ```
         * @summary Create Api Key
         * @param {BodyCreateApiKeyApiV1ApiKeysPost} bodyCreateApiKeyApiV1ApiKeysPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost: BodyCreateApiKeyApiV1ApiKeysPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAPIKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.createApiKeyApiV1ApiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all API keys for the current user  Returns metadata for all keys (name, created, expires, last_used). Does not include the actual API keys.
         * @summary List Api Keys
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.listApiKeysApiV1ApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an API key  Permanently deletes the API key. This action cannot be undone. Any clients using this key will immediately lose access.
         * @summary Revoke Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.revokeApiKeyApiV1ApiKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rotate an API key  Generates a new API key while keeping the same key_id. The old key is invalidated immediately.  **Save the new_api_key securely** - update your client configuration.
         * @summary Rotate Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RotateAPIKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.rotateApiKeyApiV1ApiKeysKeyIdRotatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeysApi - factory interface
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Create a new API key for the current user  Creates a cryptographically secure API key with bcrypt hashing. **Save the returned api_key securely** - it will not be shown again.  Maximum 5 keys per user. Revoke an existing key before creating more.  Example:     ```json     {         \"name\": \"Production API Key\",         \"expires_days\": 365     }     ```
         * @summary Create Api Key
         * @param {BodyCreateApiKeyApiV1ApiKeysPost} bodyCreateApiKeyApiV1ApiKeysPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost: BodyCreateApiKeyApiV1ApiKeysPost, options?: RawAxiosRequestConfig): AxiosPromise<CreateAPIKeyResponse> {
            return localVarFp.createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost, options).then((request) => request(axios, basePath));
        },
        /**
         * List all API keys for the current user  Returns metadata for all keys (name, created, expires, last_used). Does not include the actual API keys.
         * @summary List Api Keys
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<Array<APIKeyResponse>> {
            return localVarFp.listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an API key  Permanently deletes the API key. This action cannot be undone. Any clients using this key will immediately lose access.
         * @summary Revoke Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotate an API key  Generates a new API key while keeping the same key_id. The old key is invalidated immediately.  **Save the new_api_key securely** - update your client configuration.
         * @summary Rotate Api Key
         * @param {string} keyId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<RotateAPIKeyResponse> {
            return localVarFp.rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Create a new API key for the current user  Creates a cryptographically secure API key with bcrypt hashing. **Save the returned api_key securely** - it will not be shown again.  Maximum 5 keys per user. Revoke an existing key before creating more.  Example:     ```json     {         \"name\": \"Production API Key\",         \"expires_days\": 365     }     ```
     * @summary Create Api Key
     * @param {BodyCreateApiKeyApiV1ApiKeysPost} bodyCreateApiKeyApiV1ApiKeysPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost: BodyCreateApiKeyApiV1ApiKeysPost, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).createApiKeyApiV1ApiKeysPost(bodyCreateApiKeyApiV1ApiKeysPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all API keys for the current user  Returns metadata for all keys (name, created, expires, last_used). Does not include the actual API keys.
     * @summary List Api Keys
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).listApiKeysApiV1ApiKeysGet(hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an API key  Permanently deletes the API key. This action cannot be undone. Any clients using this key will immediately lose access.
     * @summary Revoke Api Key
     * @param {string} keyId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).revokeApiKeyApiV1ApiKeysKeyIdDelete(keyId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rotate an API key  Generates a new API key while keeping the same key_id. The old key is invalidated immediately.  **Save the new_api_key securely** - update your client configuration.
     * @summary Rotate Api Key
     * @param {string} keyId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).rotateApiKeyApiV1ApiKeysKeyIdRotatePost(keyId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * APIMetadataApi - axios parameter creator
 */
export const APIMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns API version metadata for client compatibility checking.      **Versioning Strategy:**     - **Semantic Versioning**: MAJOR.MINOR.PATCH     - **URL Versioning**: `/api/v1`, `/api/v2`, etc.     - **Header Negotiation**: `X-API-Version: 1.0` (optional)     - **Deprecation Policy**: 6-month sunset period for deprecated versions      **Breaking Changes:**     - Removing fields from responses     - Changing field types     - Removing endpoints     - Changing authentication methods      **Non-Breaking Changes:**     - Adding new endpoints     - Adding new optional fields to requests     - Adding new fields to responses     - Adding new query parameters (optional)      Use this endpoint to:     - Check current API version     - Determine if your client is compatible     - Find out when deprecated versions will be removed     - Locate API documentation
         * @summary Get API version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiVersionMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIMetadataApi - functional programming interface
 */
export const APIMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns API version metadata for client compatibility checking.      **Versioning Strategy:**     - **Semantic Versioning**: MAJOR.MINOR.PATCH     - **URL Versioning**: `/api/v1`, `/api/v2`, etc.     - **Header Negotiation**: `X-API-Version: 1.0` (optional)     - **Deprecation Policy**: 6-month sunset period for deprecated versions      **Breaking Changes:**     - Removing fields from responses     - Changing field types     - Removing endpoints     - Changing authentication methods      **Non-Breaking Changes:**     - Adding new endpoints     - Adding new optional fields to requests     - Adding new fields to responses     - Adding new query parameters (optional)      Use this endpoint to:     - Check current API version     - Determine if your client is compatible     - Find out when deprecated versions will be removed     - Locate API documentation
         * @summary Get API version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiVersionMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIVersionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiVersionMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIMetadataApi.getApiVersionMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIMetadataApi - factory interface
 */
export const APIMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIMetadataApiFp(configuration)
    return {
        /**
         * Returns API version metadata for client compatibility checking.      **Versioning Strategy:**     - **Semantic Versioning**: MAJOR.MINOR.PATCH     - **URL Versioning**: `/api/v1`, `/api/v2`, etc.     - **Header Negotiation**: `X-API-Version: 1.0` (optional)     - **Deprecation Policy**: 6-month sunset period for deprecated versions      **Breaking Changes:**     - Removing fields from responses     - Changing field types     - Removing endpoints     - Changing authentication methods      **Non-Breaking Changes:**     - Adding new endpoints     - Adding new optional fields to requests     - Adding new fields to responses     - Adding new query parameters (optional)      Use this endpoint to:     - Check current API version     - Determine if your client is compatible     - Find out when deprecated versions will be removed     - Locate API documentation
         * @summary Get API version information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiVersionMetadata(options?: RawAxiosRequestConfig): AxiosPromise<APIVersionInfo> {
            return localVarFp.getApiVersionMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIMetadataApi - object-oriented interface
 */
export class APIMetadataApi extends BaseAPI {
    /**
     * Returns API version metadata for client compatibility checking.      **Versioning Strategy:**     - **Semantic Versioning**: MAJOR.MINOR.PATCH     - **URL Versioning**: `/api/v1`, `/api/v2`, etc.     - **Header Negotiation**: `X-API-Version: 1.0` (optional)     - **Deprecation Policy**: 6-month sunset period for deprecated versions      **Breaking Changes:**     - Removing fields from responses     - Changing field types     - Removing endpoints     - Changing authentication methods      **Non-Breaking Changes:**     - Adding new endpoints     - Adding new optional fields to requests     - Adding new fields to responses     - Adding new query parameters (optional)      Use this endpoint to:     - Check current API version     - Determine if your client is compatible     - Find out when deprecated versions will be removed     - Locate API documentation
     * @summary Get API version information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getApiVersionMetadata(options?: RawAxiosRequestConfig) {
        return APIMetadataApiFp(this.configuration).getApiVersionMetadata(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user and return JWT token  This endpoint accepts username and password, validates credentials, and returns a JWT token that can be used for subsequent tool calls.  The token should be included in the \'token\' field of all tool call requests.  Example:     POST /auth/login     {         \"username\": \"alice\",         \"password\": \"alice123\"     }      Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"user_id\": \"user:alice\",         \"username\": \"alice\",         \"roles\": [\"user\", \"premium\"]     }
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginAuthLoginPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh authentication token  Supports two refresh methods: 1. Keycloak: Uses refresh_token to get new access token 2. InMemory: Validates current token and issues new one  Example (Keycloak):     POST /auth/refresh     {         \"refresh_token\": \"eyJ...\"     }  Example (InMemory):     POST /auth/refresh     {         \"current_token\": \"eyJ...\"     }  Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"refresh_token\": \"eyJ...\"  // Keycloak only     }
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenAuthRefreshPost: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('refreshTokenAuthRefreshPost', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user and return JWT token  This endpoint accepts username and password, validates credentials, and returns a JWT token that can be used for subsequent tool calls.  The token should be included in the \'token\' field of all tool call requests.  Example:     POST /auth/login     {         \"username\": \"alice\",         \"password\": \"alice123\"     }      Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"user_id\": \"user:alice\",         \"username\": \"alice\",         \"roles\": [\"user\", \"premium\"]     }
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAuthLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh authentication token  Supports two refresh methods: 1. Keycloak: Uses refresh_token to get new access token 2. InMemory: Validates current token and issues new one  Example (Keycloak):     POST /auth/refresh     {         \"refresh_token\": \"eyJ...\"     }  Example (InMemory):     POST /auth/refresh     {         \"current_token\": \"eyJ...\"     }  Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"refresh_token\": \"eyJ...\"  // Keycloak only     }
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenAuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenAuthRefreshPost(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshTokenAuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate user and return JWT token  This endpoint accepts username and password, validates credentials, and returns a JWT token that can be used for subsequent tool calls.  The token should be included in the \'token\' field of all tool call requests.  Example:     POST /auth/login     {         \"username\": \"alice\",         \"password\": \"alice123\"     }      Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"user_id\": \"user:alice\",         \"username\": \"alice\",         \"roles\": [\"user\", \"premium\"]     }
         * @summary Login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.loginAuthLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh authentication token  Supports two refresh methods: 1. Keycloak: Uses refresh_token to get new access token 2. InMemory: Validates current token and issues new one  Example (Keycloak):     POST /auth/refresh     {         \"refresh_token\": \"eyJ...\"     }  Example (InMemory):     POST /auth/refresh     {         \"current_token\": \"eyJ...\"     }  Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"refresh_token\": \"eyJ...\"  // Keycloak only     }
         * @summary Refresh Token
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenAuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.refreshTokenAuthRefreshPost(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate user and return JWT token  This endpoint accepts username and password, validates credentials, and returns a JWT token that can be used for subsequent tool calls.  The token should be included in the \'token\' field of all tool call requests.  Example:     POST /auth/login     {         \"username\": \"alice\",         \"password\": \"alice123\"     }      Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"user_id\": \"user:alice\",         \"username\": \"alice\",         \"roles\": [\"user\", \"premium\"]     }
     * @summary Login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginAuthLoginPost(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginAuthLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh authentication token  Supports two refresh methods: 1. Keycloak: Uses refresh_token to get new access token 2. InMemory: Validates current token and issues new one  Example (Keycloak):     POST /auth/refresh     {         \"refresh_token\": \"eyJ...\"     }  Example (InMemory):     POST /auth/refresh     {         \"current_token\": \"eyJ...\"     }  Response:     {         \"access_token\": \"eyJ...\",         \"token_type\": \"bearer\",         \"expires_in\": 3600,         \"refresh_token\": \"eyJ...\"  // Keycloak only     }
     * @summary Refresh Token
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshTokenAuthRefreshPost(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshTokenAuthRefreshPost(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Handle MCP messages via StreamableHTTP POST  This is the main endpoint for MCP protocol messages. Supports both regular and streaming responses.
         * @summary Handle Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMessageMessagePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available resources (convenience endpoint)
         * @summary List Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcesResourcesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available tools (convenience endpoint)
         * @summary List Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolsToolsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Root endpoint with server info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Handle MCP messages via StreamableHTTP POST  This is the main endpoint for MCP protocol messages. Supports both regular and streaming responses.
         * @summary Handle Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleMessageMessagePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleMessageMessagePost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.handleMessageMessagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available resources (convenience endpoint)
         * @summary List Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listResourcesResourcesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listResourcesResourcesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listResourcesResourcesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available tools (convenience endpoint)
         * @summary List Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listToolsToolsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listToolsToolsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listToolsToolsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Root endpoint with server info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Handle MCP messages via StreamableHTTP POST  This is the main endpoint for MCP protocol messages. Supports both regular and streaming responses.
         * @summary Handle Message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleMessageMessagePost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.handleMessageMessagePost(options).then((request) => request(axios, basePath));
        },
        /**
         * List available resources (convenience endpoint)
         * @summary List Resources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listResourcesResourcesGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.listResourcesResourcesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List available tools (convenience endpoint)
         * @summary List Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolsToolsGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.listToolsToolsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Root endpoint with server info
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Handle MCP messages via StreamableHTTP POST  This is the main endpoint for MCP protocol messages. Supports both regular and streaming responses.
     * @summary Handle Message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleMessageMessagePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).handleMessageMessagePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available resources (convenience endpoint)
     * @summary List Resources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listResourcesResourcesGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listResourcesResourcesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available tools (convenience endpoint)
     * @summary List Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listToolsToolsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listToolsToolsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Root endpoint with server info
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GDPRComplianceApi - axios parameter creator
 */
export const GDPRComplianceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete user account and all data (GDPR Article 17 - Right to Erasure)  **WARNING**: This is an irreversible operation that permanently deletes all user data.  **GDPR Article 17**: The data subject shall have the right to obtain from the controller the erasure of personal data concerning him or her without undue delay.  **Query Parameters**: - `confirm`: Must be set to `true` to confirm deletion  **What gets deleted**: - User profile and account - All sessions - All conversations and messages - All preferences and settings - All authorization tuples  **What gets anonymized** (retained for compliance): - Audit logs (user_id replaced with hash)  **Response**: Deletion result with details
         * @summary Delete User Account
         * @param {boolean} confirm Must be true to confirm account deletion
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAccountApiV1UsersMeDelete: async (confirm: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirm' is not null or undefined
            assertParamExists('deleteUserAccountApiV1UsersMeDelete', 'confirm', confirm)
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (confirm !== undefined) {
                localVarQueryParameter['confirm'] = confirm;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export user data in portable format (GDPR Article 20 - Right to Data Portability)  **GDPR Article 20**: The data subject shall have the right to receive the personal data concerning him or her in a structured, commonly used and machine-readable format.  **Query Parameters**: - `format`: Export format (json or csv)  **Response**: File download in requested format
         * @summary Export User Data
         * @param {string} [format] Export format: json or csv
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUserDataApiV1UsersMeExportGet: async (format?: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current consent status (GDPR Article 21 - Right to Object)  Returns all consent preferences for the authenticated user.  **Response**: Current consent status for all consent types
         * @summary Get Consent Status
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentStatusApiV1UsersMeConsentGet: async (hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export all user data (GDPR Article 15 - Right to Access)  Returns all personal data associated with the authenticated user.  **GDPR Article 15**: The data subject shall have the right to obtain from the controller confirmation as to whether or not personal data concerning him or her are being processed, and access to the personal data.  **Response**: Complete JSON export of all user data including: - User profile - Sessions - Conversations - Preferences - Audit log - Consents
         * @summary Get User Data
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataApiV1UsersMeDataGet: async (hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user consent preferences (GDPR Article 21 - Right to Object)  **GDPR Article 21**: The data subject shall have the right to object at any time to processing of personal data concerning him or her.  **Request Body**: Consent type and whether it\'s granted  **Response**: Current consent status for all types
         * @summary Update Consent
         * @param {BodyUpdateConsentApiV1UsersMeConsentPost} bodyUpdateConsentApiV1UsersMeConsentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsentApiV1UsersMeConsentPost: async (bodyUpdateConsentApiV1UsersMeConsentPost: BodyUpdateConsentApiV1UsersMeConsentPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyUpdateConsentApiV1UsersMeConsentPost' is not null or undefined
            assertParamExists('updateConsentApiV1UsersMeConsentPost', 'bodyUpdateConsentApiV1UsersMeConsentPost', bodyUpdateConsentApiV1UsersMeConsentPost)
            const localVarPath = `/api/v1/users/me/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateConsentApiV1UsersMeConsentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile (GDPR Article 16 - Right to Rectification)  **GDPR Article 16**: The data subject shall have the right to obtain from the controller without undue delay the rectification of inaccurate personal data concerning him or her.  **Request Body**: Profile fields to update (only provided fields are updated)  **Response**: Updated user profile
         * @summary Update User Profile
         * @param {BodyUpdateUserProfileApiV1UsersMePatch} bodyUpdateUserProfileApiV1UsersMePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfileApiV1UsersMePatch: async (bodyUpdateUserProfileApiV1UsersMePatch: BodyUpdateUserProfileApiV1UsersMePatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyUpdateUserProfileApiV1UsersMePatch' is not null or undefined
            assertParamExists('updateUserProfileApiV1UsersMePatch', 'bodyUpdateUserProfileApiV1UsersMePatch', bodyUpdateUserProfileApiV1UsersMePatch)
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserProfileApiV1UsersMePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GDPRComplianceApi - functional programming interface
 */
export const GDPRComplianceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GDPRComplianceApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete user account and all data (GDPR Article 17 - Right to Erasure)  **WARNING**: This is an irreversible operation that permanently deletes all user data.  **GDPR Article 17**: The data subject shall have the right to obtain from the controller the erasure of personal data concerning him or her without undue delay.  **Query Parameters**: - `confirm`: Must be set to `true` to confirm deletion  **What gets deleted**: - User profile and account - All sessions - All conversations and messages - All preferences and settings - All authorization tuples  **What gets anonymized** (retained for compliance): - Audit logs (user_id replaced with hash)  **Response**: Deletion result with details
         * @summary Delete User Account
         * @param {boolean} confirm Must be true to confirm account deletion
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAccountApiV1UsersMeDelete(confirm: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAccountApiV1UsersMeDelete(confirm, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.deleteUserAccountApiV1UsersMeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export user data in portable format (GDPR Article 20 - Right to Data Portability)  **GDPR Article 20**: The data subject shall have the right to receive the personal data concerning him or her in a structured, commonly used and machine-readable format.  **Query Parameters**: - `format`: Export format (json or csv)  **Response**: File download in requested format
         * @summary Export User Data
         * @param {string} [format] Export format: json or csv
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUserDataApiV1UsersMeExportGet(format?: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUserDataApiV1UsersMeExportGet(format, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.exportUserDataApiV1UsersMeExportGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current consent status (GDPR Article 21 - Right to Object)  Returns all consent preferences for the authenticated user.  **Response**: Current consent status for all consent types
         * @summary Get Consent Status
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.getConsentStatusApiV1UsersMeConsentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export all user data (GDPR Article 15 - Right to Access)  Returns all personal data associated with the authenticated user.  **GDPR Article 15**: The data subject shall have the right to obtain from the controller confirmation as to whether or not personal data concerning him or her are being processed, and access to the personal data.  **Response**: Complete JSON export of all user data including: - User profile - Sessions - Conversations - Preferences - Audit log - Consents
         * @summary Get User Data
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDataExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.getUserDataApiV1UsersMeDataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user consent preferences (GDPR Article 21 - Right to Object)  **GDPR Article 21**: The data subject shall have the right to object at any time to processing of personal data concerning him or her.  **Request Body**: Consent type and whether it\'s granted  **Response**: Current consent status for all types
         * @summary Update Consent
         * @param {BodyUpdateConsentApiV1UsersMeConsentPost} bodyUpdateConsentApiV1UsersMeConsentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost: BodyUpdateConsentApiV1UsersMeConsentPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.updateConsentApiV1UsersMeConsentPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user profile (GDPR Article 16 - Right to Rectification)  **GDPR Article 16**: The data subject shall have the right to obtain from the controller without undue delay the rectification of inaccurate personal data concerning him or her.  **Request Body**: Profile fields to update (only provided fields are updated)  **Response**: Updated user profile
         * @summary Update User Profile
         * @param {BodyUpdateUserProfileApiV1UsersMePatch} bodyUpdateUserProfileApiV1UsersMePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch: BodyUpdateUserProfileApiV1UsersMePatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GDPRComplianceApi.updateUserProfileApiV1UsersMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GDPRComplianceApi - factory interface
 */
export const GDPRComplianceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GDPRComplianceApiFp(configuration)
    return {
        /**
         * Delete user account and all data (GDPR Article 17 - Right to Erasure)  **WARNING**: This is an irreversible operation that permanently deletes all user data.  **GDPR Article 17**: The data subject shall have the right to obtain from the controller the erasure of personal data concerning him or her without undue delay.  **Query Parameters**: - `confirm`: Must be set to `true` to confirm deletion  **What gets deleted**: - User profile and account - All sessions - All conversations and messages - All preferences and settings - All authorization tuples  **What gets anonymized** (retained for compliance): - Audit logs (user_id replaced with hash)  **Response**: Deletion result with details
         * @summary Delete User Account
         * @param {boolean} confirm Must be true to confirm account deletion
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAccountApiV1UsersMeDelete(confirm: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.deleteUserAccountApiV1UsersMeDelete(confirm, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Export user data in portable format (GDPR Article 20 - Right to Data Portability)  **GDPR Article 20**: The data subject shall have the right to receive the personal data concerning him or her in a structured, commonly used and machine-readable format.  **Query Parameters**: - `format`: Export format (json or csv)  **Response**: File download in requested format
         * @summary Export User Data
         * @param {string} [format] Export format: json or csv
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUserDataApiV1UsersMeExportGet(format?: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.exportUserDataApiV1UsersMeExportGet(format, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current consent status (GDPR Article 21 - Right to Object)  Returns all consent preferences for the authenticated user.  **Response**: Current consent status for all consent types
         * @summary Get Consent Status
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<ConsentResponse> {
            return localVarFp.getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Export all user data (GDPR Article 15 - Right to Access)  Returns all personal data associated with the authenticated user.  **GDPR Article 15**: The data subject shall have the right to obtain from the controller confirmation as to whether or not personal data concerning him or her are being processed, and access to the personal data.  **Response**: Complete JSON export of all user data including: - User profile - Sessions - Conversations - Preferences - Audit log - Consents
         * @summary Get User Data
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<UserDataExport> {
            return localVarFp.getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user consent preferences (GDPR Article 21 - Right to Object)  **GDPR Article 21**: The data subject shall have the right to object at any time to processing of personal data concerning him or her.  **Request Body**: Consent type and whether it\'s granted  **Response**: Current consent status for all types
         * @summary Update Consent
         * @param {BodyUpdateConsentApiV1UsersMeConsentPost} bodyUpdateConsentApiV1UsersMeConsentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost: BodyUpdateConsentApiV1UsersMeConsentPost, options?: RawAxiosRequestConfig): AxiosPromise<ConsentResponse> {
            return localVarFp.updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile (GDPR Article 16 - Right to Rectification)  **GDPR Article 16**: The data subject shall have the right to obtain from the controller without undue delay the rectification of inaccurate personal data concerning him or her.  **Request Body**: Profile fields to update (only provided fields are updated)  **Response**: Updated user profile
         * @summary Update User Profile
         * @param {BodyUpdateUserProfileApiV1UsersMePatch} bodyUpdateUserProfileApiV1UsersMePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch: BodyUpdateUserProfileApiV1UsersMePatch, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GDPRComplianceApi - object-oriented interface
 */
export class GDPRComplianceApi extends BaseAPI {
    /**
     * Delete user account and all data (GDPR Article 17 - Right to Erasure)  **WARNING**: This is an irreversible operation that permanently deletes all user data.  **GDPR Article 17**: The data subject shall have the right to obtain from the controller the erasure of personal data concerning him or her without undue delay.  **Query Parameters**: - `confirm`: Must be set to `true` to confirm deletion  **What gets deleted**: - User profile and account - All sessions - All conversations and messages - All preferences and settings - All authorization tuples  **What gets anonymized** (retained for compliance): - Audit logs (user_id replaced with hash)  **Response**: Deletion result with details
     * @summary Delete User Account
     * @param {boolean} confirm Must be true to confirm account deletion
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserAccountApiV1UsersMeDelete(confirm: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).deleteUserAccountApiV1UsersMeDelete(confirm, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export user data in portable format (GDPR Article 20 - Right to Data Portability)  **GDPR Article 20**: The data subject shall have the right to receive the personal data concerning him or her in a structured, commonly used and machine-readable format.  **Query Parameters**: - `format`: Export format (json or csv)  **Response**: File download in requested format
     * @summary Export User Data
     * @param {string} [format] Export format: json or csv
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public exportUserDataApiV1UsersMeExportGet(format?: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).exportUserDataApiV1UsersMeExportGet(format, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current consent status (GDPR Article 21 - Right to Object)  Returns all consent preferences for the authenticated user.  **Response**: Current consent status for all consent types
     * @summary Get Consent Status
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).getConsentStatusApiV1UsersMeConsentGet(hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export all user data (GDPR Article 15 - Right to Access)  Returns all personal data associated with the authenticated user.  **GDPR Article 15**: The data subject shall have the right to obtain from the controller confirmation as to whether or not personal data concerning him or her are being processed, and access to the personal data.  **Response**: Complete JSON export of all user data including: - User profile - Sessions - Conversations - Preferences - Audit log - Consents
     * @summary Get User Data
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).getUserDataApiV1UsersMeDataGet(hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user consent preferences (GDPR Article 21 - Right to Object)  **GDPR Article 21**: The data subject shall have the right to object at any time to processing of personal data concerning him or her.  **Request Body**: Consent type and whether it\'s granted  **Response**: Current consent status for all types
     * @summary Update Consent
     * @param {BodyUpdateConsentApiV1UsersMeConsentPost} bodyUpdateConsentApiV1UsersMeConsentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost: BodyUpdateConsentApiV1UsersMeConsentPost, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).updateConsentApiV1UsersMeConsentPost(bodyUpdateConsentApiV1UsersMeConsentPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user profile (GDPR Article 16 - Right to Rectification)  **GDPR Article 16**: The data subject shall have the right to obtain from the controller without undue delay the rectification of inaccurate personal data concerning him or her.  **Request Body**: Profile fields to update (only provided fields are updated)  **Response**: Updated user profile
     * @summary Update User Profile
     * @param {BodyUpdateUserProfileApiV1UsersMePatch} bodyUpdateUserProfileApiV1UsersMePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch: BodyUpdateUserProfileApiV1UsersMePatch, options?: RawAxiosRequestConfig) {
        return GDPRComplianceApiFp(this.configuration).updateUserProfileApiV1UsersMePatch(bodyUpdateUserProfileApiV1UsersMePatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SCIM20Api - axios parameter creator
 */
export const SCIM20ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new group (SCIM 2.0)  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],         \"displayName\": \"Engineering\",         \"members\": [             {\"value\": \"user-id-123\", \"display\": \"Alice Smith\"}         ]     }     ```
         * @summary Create Group
         * @param {BodyCreateGroupScimV2GroupsPost} bodyCreateGroupScimV2GroupsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupScimV2GroupsPost: async (bodyCreateGroupScimV2GroupsPost: BodyCreateGroupScimV2GroupsPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateGroupScimV2GroupsPost' is not null or undefined
            assertParamExists('createGroupScimV2GroupsPost', 'bodyCreateGroupScimV2GroupsPost', bodyCreateGroupScimV2GroupsPost)
            const localVarPath = `/scim/v2/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateGroupScimV2GroupsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user (SCIM 2.0)  Provisions user in Keycloak and syncs roles to OpenFGA.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],         \"userName\": \"alice@example.com\",         \"name\": {             \"givenName\": \"Alice\",             \"familyName\": \"Smith\"         },         \"emails\": [{             \"value\": \"alice@example.com\",             \"primary\": true         }],         \"active\": true     }     ```
         * @summary Create User
         * @param {BodyCreateUserScimV2UsersPost} bodyCreateUserScimV2UsersPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserScimV2UsersPost: async (bodyCreateUserScimV2UsersPost: BodyCreateUserScimV2UsersPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateUserScimV2UsersPost' is not null or undefined
            assertParamExists('createUserScimV2UsersPost', 'bodyCreateUserScimV2UsersPost', bodyCreateUserScimV2UsersPost)
            const localVarPath = `/scim/v2/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateUserScimV2UsersPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete (deactivate) user (SCIM 2.0)  Deactivates user in Keycloak and removes OpenFGA tuples.
         * @summary Delete User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserScimV2UsersUserIdDelete: async (userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserScimV2UsersUserIdDelete', 'userId', userId)
            const localVarPath = `/scim/v2/Users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get group by ID (SCIM 2.0)
         * @summary Get Group
         * @param {string} groupId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScimV2GroupsGroupIdGet: async (groupId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupScimV2GroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/scim/v2/Groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user by ID (SCIM 2.0)  Returns user in SCIM format.
         * @summary Get User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScimV2UsersUserIdGet: async (userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserScimV2UsersUserIdGet', 'userId', userId)
            const localVarPath = `/scim/v2/Users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List/search users (SCIM 2.0)  Supports basic filtering (e.g., \'userName eq \"alice@example.com\"\').
         * @summary List Users
         * @param {string | null} [filter] SCIM filter expression
         * @param {number} [startIndex] 1-based start index
         * @param {number} [count] Number of results
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersScimV2UsersGet: async (filter?: string | null, startIndex?: number, count?: number, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scim/v2/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace user (SCIM 2.0 PUT)  Replaces entire user resource.
         * @summary Replace User
         * @param {string} userId 
         * @param {BodyReplaceUserScimV2UsersUserIdPut} bodyReplaceUserScimV2UsersUserIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserScimV2UsersUserIdPut: async (userId: string, bodyReplaceUserScimV2UsersUserIdPut: BodyReplaceUserScimV2UsersUserIdPut, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('replaceUserScimV2UsersUserIdPut', 'userId', userId)
            // verify required parameter 'bodyReplaceUserScimV2UsersUserIdPut' is not null or undefined
            assertParamExists('replaceUserScimV2UsersUserIdPut', 'bodyReplaceUserScimV2UsersUserIdPut', bodyReplaceUserScimV2UsersUserIdPut)
            const localVarPath = `/scim/v2/Users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyReplaceUserScimV2UsersUserIdPut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user with PATCH operations (SCIM 2.0)  Supports add, remove, replace operations.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],         \"Operations\": [             {                 \"op\": \"replace\",                 \"path\": \"active\",                 \"value\": false             }         ]     }     ```
         * @summary Update User
         * @param {string} userId 
         * @param {BodyUpdateUserScimV2UsersUserIdPatch} bodyUpdateUserScimV2UsersUserIdPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserScimV2UsersUserIdPatch: async (userId: string, bodyUpdateUserScimV2UsersUserIdPatch: BodyUpdateUserScimV2UsersUserIdPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserScimV2UsersUserIdPatch', 'userId', userId)
            // verify required parameter 'bodyUpdateUserScimV2UsersUserIdPatch' is not null or undefined
            assertParamExists('updateUserScimV2UsersUserIdPatch', 'bodyUpdateUserScimV2UsersUserIdPatch', bodyUpdateUserScimV2UsersUserIdPatch)
            const localVarPath = `/scim/v2/Users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserScimV2UsersUserIdPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SCIM20Api - functional programming interface
 */
export const SCIM20ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SCIM20ApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new group (SCIM 2.0)  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],         \"displayName\": \"Engineering\",         \"members\": [             {\"value\": \"user-id-123\", \"display\": \"Alice Smith\"}         ]     }     ```
         * @summary Create Group
         * @param {BodyCreateGroupScimV2GroupsPost} bodyCreateGroupScimV2GroupsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost: BodyCreateGroupScimV2GroupsPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.createGroupScimV2GroupsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user (SCIM 2.0)  Provisions user in Keycloak and syncs roles to OpenFGA.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],         \"userName\": \"alice@example.com\",         \"name\": {             \"givenName\": \"Alice\",             \"familyName\": \"Smith\"         },         \"emails\": [{             \"value\": \"alice@example.com\",             \"primary\": true         }],         \"active\": true     }     ```
         * @summary Create User
         * @param {BodyCreateUserScimV2UsersPost} bodyCreateUserScimV2UsersPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost: BodyCreateUserScimV2UsersPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.createUserScimV2UsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete (deactivate) user (SCIM 2.0)  Deactivates user in Keycloak and removes OpenFGA tuples.
         * @summary Delete User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserScimV2UsersUserIdDelete(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserScimV2UsersUserIdDelete(userId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.deleteUserScimV2UsersUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get group by ID (SCIM 2.0)
         * @summary Get Group
         * @param {string} groupId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupScimV2GroupsGroupIdGet(groupId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupScimV2GroupsGroupIdGet(groupId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.getGroupScimV2GroupsGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user by ID (SCIM 2.0)  Returns user in SCIM format.
         * @summary Get User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserScimV2UsersUserIdGet(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserScimV2UsersUserIdGet(userId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.getUserScimV2UsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List/search users (SCIM 2.0)  Supports basic filtering (e.g., \'userName eq \"alice@example.com\"\').
         * @summary List Users
         * @param {string | null} [filter] SCIM filter expression
         * @param {number} [startIndex] 1-based start index
         * @param {number} [count] Number of results
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersScimV2UsersGet(filter?: string | null, startIndex?: number, count?: number, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersScimV2UsersGet(filter, startIndex, count, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.listUsersScimV2UsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replace user (SCIM 2.0 PUT)  Replaces entire user resource.
         * @summary Replace User
         * @param {string} userId 
         * @param {BodyReplaceUserScimV2UsersUserIdPut} bodyReplaceUserScimV2UsersUserIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceUserScimV2UsersUserIdPut(userId: string, bodyReplaceUserScimV2UsersUserIdPut: BodyReplaceUserScimV2UsersUserIdPut, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceUserScimV2UsersUserIdPut(userId, bodyReplaceUserScimV2UsersUserIdPut, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.replaceUserScimV2UsersUserIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user with PATCH operations (SCIM 2.0)  Supports add, remove, replace operations.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],         \"Operations\": [             {                 \"op\": \"replace\",                 \"path\": \"active\",                 \"value\": false             }         ]     }     ```
         * @summary Update User
         * @param {string} userId 
         * @param {BodyUpdateUserScimV2UsersUserIdPatch} bodyUpdateUserScimV2UsersUserIdPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserScimV2UsersUserIdPatch(userId: string, bodyUpdateUserScimV2UsersUserIdPatch: BodyUpdateUserScimV2UsersUserIdPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SCIMUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserScimV2UsersUserIdPatch(userId, bodyUpdateUserScimV2UsersUserIdPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SCIM20Api.updateUserScimV2UsersUserIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SCIM20Api - factory interface
 */
export const SCIM20ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SCIM20ApiFp(configuration)
    return {
        /**
         * Create a new group (SCIM 2.0)  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],         \"displayName\": \"Engineering\",         \"members\": [             {\"value\": \"user-id-123\", \"display\": \"Alice Smith\"}         ]     }     ```
         * @summary Create Group
         * @param {BodyCreateGroupScimV2GroupsPost} bodyCreateGroupScimV2GroupsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost: BodyCreateGroupScimV2GroupsPost, options?: RawAxiosRequestConfig): AxiosPromise<SCIMGroup> {
            return localVarFp.createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user (SCIM 2.0)  Provisions user in Keycloak and syncs roles to OpenFGA.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],         \"userName\": \"alice@example.com\",         \"name\": {             \"givenName\": \"Alice\",             \"familyName\": \"Smith\"         },         \"emails\": [{             \"value\": \"alice@example.com\",             \"primary\": true         }],         \"active\": true     }     ```
         * @summary Create User
         * @param {BodyCreateUserScimV2UsersPost} bodyCreateUserScimV2UsersPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost: BodyCreateUserScimV2UsersPost, options?: RawAxiosRequestConfig): AxiosPromise<SCIMUser> {
            return localVarFp.createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete (deactivate) user (SCIM 2.0)  Deactivates user in Keycloak and removes OpenFGA tuples.
         * @summary Delete User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserScimV2UsersUserIdDelete(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUserScimV2UsersUserIdDelete(userId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Get group by ID (SCIM 2.0)
         * @summary Get Group
         * @param {string} groupId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupScimV2GroupsGroupIdGet(groupId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<SCIMGroup> {
            return localVarFp.getGroupScimV2GroupsGroupIdGet(groupId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user by ID (SCIM 2.0)  Returns user in SCIM format.
         * @summary Get User
         * @param {string} userId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserScimV2UsersUserIdGet(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<SCIMUser> {
            return localVarFp.getUserScimV2UsersUserIdGet(userId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * List/search users (SCIM 2.0)  Supports basic filtering (e.g., \'userName eq \"alice@example.com\"\').
         * @summary List Users
         * @param {string | null} [filter] SCIM filter expression
         * @param {number} [startIndex] 1-based start index
         * @param {number} [count] Number of results
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersScimV2UsersGet(filter?: string | null, startIndex?: number, count?: number, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<SCIMListResponse> {
            return localVarFp.listUsersScimV2UsersGet(filter, startIndex, count, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace user (SCIM 2.0 PUT)  Replaces entire user resource.
         * @summary Replace User
         * @param {string} userId 
         * @param {BodyReplaceUserScimV2UsersUserIdPut} bodyReplaceUserScimV2UsersUserIdPut 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceUserScimV2UsersUserIdPut(userId: string, bodyReplaceUserScimV2UsersUserIdPut: BodyReplaceUserScimV2UsersUserIdPut, options?: RawAxiosRequestConfig): AxiosPromise<SCIMUser> {
            return localVarFp.replaceUserScimV2UsersUserIdPut(userId, bodyReplaceUserScimV2UsersUserIdPut, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user with PATCH operations (SCIM 2.0)  Supports add, remove, replace operations.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],         \"Operations\": [             {                 \"op\": \"replace\",                 \"path\": \"active\",                 \"value\": false             }         ]     }     ```
         * @summary Update User
         * @param {string} userId 
         * @param {BodyUpdateUserScimV2UsersUserIdPatch} bodyUpdateUserScimV2UsersUserIdPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserScimV2UsersUserIdPatch(userId: string, bodyUpdateUserScimV2UsersUserIdPatch: BodyUpdateUserScimV2UsersUserIdPatch, options?: RawAxiosRequestConfig): AxiosPromise<SCIMUser> {
            return localVarFp.updateUserScimV2UsersUserIdPatch(userId, bodyUpdateUserScimV2UsersUserIdPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SCIM20Api - object-oriented interface
 */
export class SCIM20Api extends BaseAPI {
    /**
     * Create a new group (SCIM 2.0)  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:Group\"],         \"displayName\": \"Engineering\",         \"members\": [             {\"value\": \"user-id-123\", \"display\": \"Alice Smith\"}         ]     }     ```
     * @summary Create Group
     * @param {BodyCreateGroupScimV2GroupsPost} bodyCreateGroupScimV2GroupsPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost: BodyCreateGroupScimV2GroupsPost, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).createGroupScimV2GroupsPost(bodyCreateGroupScimV2GroupsPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user (SCIM 2.0)  Provisions user in Keycloak and syncs roles to OpenFGA.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:schemas:core:2.0:User\"],         \"userName\": \"alice@example.com\",         \"name\": {             \"givenName\": \"Alice\",             \"familyName\": \"Smith\"         },         \"emails\": [{             \"value\": \"alice@example.com\",             \"primary\": true         }],         \"active\": true     }     ```
     * @summary Create User
     * @param {BodyCreateUserScimV2UsersPost} bodyCreateUserScimV2UsersPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost: BodyCreateUserScimV2UsersPost, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).createUserScimV2UsersPost(bodyCreateUserScimV2UsersPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete (deactivate) user (SCIM 2.0)  Deactivates user in Keycloak and removes OpenFGA tuples.
     * @summary Delete User
     * @param {string} userId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteUserScimV2UsersUserIdDelete(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).deleteUserScimV2UsersUserIdDelete(userId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get group by ID (SCIM 2.0)
     * @summary Get Group
     * @param {string} groupId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGroupScimV2GroupsGroupIdGet(groupId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).getGroupScimV2GroupsGroupIdGet(groupId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user by ID (SCIM 2.0)  Returns user in SCIM format.
     * @summary Get User
     * @param {string} userId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserScimV2UsersUserIdGet(userId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).getUserScimV2UsersUserIdGet(userId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List/search users (SCIM 2.0)  Supports basic filtering (e.g., \'userName eq \"alice@example.com\"\').
     * @summary List Users
     * @param {string | null} [filter] SCIM filter expression
     * @param {number} [startIndex] 1-based start index
     * @param {number} [count] Number of results
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsersScimV2UsersGet(filter?: string | null, startIndex?: number, count?: number, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).listUsersScimV2UsersGet(filter, startIndex, count, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace user (SCIM 2.0 PUT)  Replaces entire user resource.
     * @summary Replace User
     * @param {string} userId 
     * @param {BodyReplaceUserScimV2UsersUserIdPut} bodyReplaceUserScimV2UsersUserIdPut 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public replaceUserScimV2UsersUserIdPut(userId: string, bodyReplaceUserScimV2UsersUserIdPut: BodyReplaceUserScimV2UsersUserIdPut, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).replaceUserScimV2UsersUserIdPut(userId, bodyReplaceUserScimV2UsersUserIdPut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user with PATCH operations (SCIM 2.0)  Supports add, remove, replace operations.  Example:     ```json     {         \"schemas\": [\"urn:ietf:params:scim:api:messages:2.0:PatchOp\"],         \"Operations\": [             {                 \"op\": \"replace\",                 \"path\": \"active\",                 \"value\": false             }         ]     }     ```
     * @summary Update User
     * @param {string} userId 
     * @param {BodyUpdateUserScimV2UsersUserIdPatch} bodyUpdateUserScimV2UsersUserIdPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserScimV2UsersUserIdPatch(userId: string, bodyUpdateUserScimV2UsersUserIdPatch: BodyUpdateUserScimV2UsersUserIdPatch, options?: RawAxiosRequestConfig) {
        return SCIM20ApiFp(this.configuration).updateUserScimV2UsersUserIdPatch(userId, bodyUpdateUserScimV2UsersUserIdPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicePrincipalsApi - axios parameter creator
 */
export const ServicePrincipalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Associate service principal with a user for permission inheritance  Links a service principal to a user, optionally enabling permission inheritance. When inherit_permissions is true, the service principal can act on behalf of the user and inherit all their permissions.
         * @summary Associate Service Principal With User
         * @param {string} serviceId 
         * @param {string} userId 
         * @param {boolean} [inheritPermissions] 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost: async (serviceId: string, userId: string, inheritPermissions?: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost', 'serviceId', serviceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost', 'userId', userId)
            const localVarPath = `/api/v1/service-principals/{service_id}/associate-user`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (inheritPermissions !== undefined) {
                localVarQueryParameter['inherit_permissions'] = inheritPermissions;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new service principal  Creates a service principal with the specified authentication mode. The calling user becomes the owner of the service principal.  Returns the created service principal with credentials (client_secret). **Save the client_secret securely** - it will not be shown again.  Example:     ```json     {         \"name\": \"Batch ETL Job\",         \"description\": \"Nightly data processing\",         \"authentication_mode\": \"client_credentials\",         \"associated_user_id\": \"user:alice\",         \"inherit_permissions\": true     }     ```
         * @summary Create Service Principal
         * @param {BodyCreateServicePrincipalApiV1ServicePrincipalsPost} bodyCreateServicePrincipalApiV1ServicePrincipalsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePrincipalApiV1ServicePrincipalsPost: async (bodyCreateServicePrincipalApiV1ServicePrincipalsPost: BodyCreateServicePrincipalApiV1ServicePrincipalsPost, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyCreateServicePrincipalApiV1ServicePrincipalsPost' is not null or undefined
            assertParamExists('createServicePrincipalApiV1ServicePrincipalsPost', 'bodyCreateServicePrincipalApiV1ServicePrincipalsPost', bodyCreateServicePrincipalApiV1ServicePrincipalsPost)
            const localVarPath = `/api/v1/service-principals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyCreateServicePrincipalApiV1ServicePrincipalsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a service principal  Permanently deletes the service principal from Keycloak and OpenFGA. This action cannot be undone.
         * @summary Delete Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete: async (serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete', 'serviceId', serviceId)
            const localVarPath = `/api/v1/service-principals/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a specific service principal  Returns service principal details if the current user is the owner.
         * @summary Get Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicePrincipalApiV1ServicePrincipalsServiceIdGet: async (serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('getServicePrincipalApiV1ServicePrincipalsServiceIdGet', 'serviceId', serviceId)
            const localVarPath = `/api/v1/service-principals/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List service principals owned by the current user  Returns all service principals where the current user is the owner. Does not include client secrets.
         * @summary List Service Principals
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePrincipalsApiV1ServicePrincipalsGet: async (hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/service-principals/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rotate service principal secret  Generates a new client secret for the service principal. The old secret will be invalidated immediately.  **Save the new client_secret securely** - update your service configuration before the old secret expires.
         * @summary Rotate Service Principal Secret
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost: async (serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost', 'serviceId', serviceId)
            const localVarPath = `/api/v1/service-principals/{service_id}/rotate-secret`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hTTPAuthorizationCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicePrincipalsApi - functional programming interface
 */
export const ServicePrincipalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicePrincipalsApiAxiosParamCreator(configuration)
    return {
        /**
         * Associate service principal with a user for permission inheritance  Links a service principal to a user, optionally enabling permission inheritance. When inherit_permissions is true, the service principal can act on behalf of the user and inherit all their permissions.
         * @summary Associate Service Principal With User
         * @param {string} serviceId 
         * @param {string} userId 
         * @param {boolean} [inheritPermissions] 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId: string, userId: string, inheritPermissions?: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePrincipalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId, userId, inheritPermissions, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new service principal  Creates a service principal with the specified authentication mode. The calling user becomes the owner of the service principal.  Returns the created service principal with credentials (client_secret). **Save the client_secret securely** - it will not be shown again.  Example:     ```json     {         \"name\": \"Batch ETL Job\",         \"description\": \"Nightly data processing\",         \"authentication_mode\": \"client_credentials\",         \"associated_user_id\": \"user:alice\",         \"inherit_permissions\": true     }     ```
         * @summary Create Service Principal
         * @param {BodyCreateServicePrincipalApiV1ServicePrincipalsPost} bodyCreateServicePrincipalApiV1ServicePrincipalsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost: BodyCreateServicePrincipalApiV1ServicePrincipalsPost, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateServicePrincipalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.createServicePrincipalApiV1ServicePrincipalsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a service principal  Permanently deletes the service principal from Keycloak and OpenFGA. This action cannot be undone.
         * @summary Delete Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details of a specific service principal  Returns service principal details if the current user is the owner.
         * @summary Get Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicePrincipalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.getServicePrincipalApiV1ServicePrincipalsServiceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List service principals owned by the current user  Returns all service principals where the current user is the owner. Does not include client secrets.
         * @summary List Service Principals
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServicePrincipalResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.listServicePrincipalsApiV1ServicePrincipalsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rotate service principal secret  Generates a new client secret for the service principal. The old secret will be invalidated immediately.  **Save the new client_secret securely** - update your service configuration before the old secret expires.
         * @summary Rotate Service Principal Secret
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RotateSecretResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId, hTTPAuthorizationCredentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServicePrincipalsApi.rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServicePrincipalsApi - factory interface
 */
export const ServicePrincipalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicePrincipalsApiFp(configuration)
    return {
        /**
         * Associate service principal with a user for permission inheritance  Links a service principal to a user, optionally enabling permission inheritance. When inherit_permissions is true, the service principal can act on behalf of the user and inherit all their permissions.
         * @summary Associate Service Principal With User
         * @param {string} serviceId 
         * @param {string} userId 
         * @param {boolean} [inheritPermissions] 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId: string, userId: string, inheritPermissions?: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<ServicePrincipalResponse> {
            return localVarFp.associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId, userId, inheritPermissions, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new service principal  Creates a service principal with the specified authentication mode. The calling user becomes the owner of the service principal.  Returns the created service principal with credentials (client_secret). **Save the client_secret securely** - it will not be shown again.  Example:     ```json     {         \"name\": \"Batch ETL Job\",         \"description\": \"Nightly data processing\",         \"authentication_mode\": \"client_credentials\",         \"associated_user_id\": \"user:alice\",         \"inherit_permissions\": true     }     ```
         * @summary Create Service Principal
         * @param {BodyCreateServicePrincipalApiV1ServicePrincipalsPost} bodyCreateServicePrincipalApiV1ServicePrincipalsPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost: BodyCreateServicePrincipalApiV1ServicePrincipalsPost, options?: RawAxiosRequestConfig): AxiosPromise<CreateServicePrincipalResponse> {
            return localVarFp.createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a service principal  Permanently deletes the service principal from Keycloak and OpenFGA. This action cannot be undone.
         * @summary Delete Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a specific service principal  Returns service principal details if the current user is the owner.
         * @summary Get Service Principal
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<ServicePrincipalResponse> {
            return localVarFp.getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * List service principals owned by the current user  Returns all service principals where the current user is the owner. Does not include client secrets.
         * @summary List Service Principals
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<Array<ServicePrincipalResponse>> {
            return localVarFp.listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Rotate service principal secret  Generates a new client secret for the service principal. The old secret will be invalidated immediately.  **Save the new client_secret securely** - update your service configuration before the old secret expires.
         * @summary Rotate Service Principal Secret
         * @param {string} serviceId 
         * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig): AxiosPromise<RotateSecretResponse> {
            return localVarFp.rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicePrincipalsApi - object-oriented interface
 */
export class ServicePrincipalsApi extends BaseAPI {
    /**
     * Associate service principal with a user for permission inheritance  Links a service principal to a user, optionally enabling permission inheritance. When inherit_permissions is true, the service principal can act on behalf of the user and inherit all their permissions.
     * @summary Associate Service Principal With User
     * @param {string} serviceId 
     * @param {string} userId 
     * @param {boolean} [inheritPermissions] 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId: string, userId: string, inheritPermissions?: boolean, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).associateServicePrincipalWithUserApiV1ServicePrincipalsServiceIdAssociateUserPost(serviceId, userId, inheritPermissions, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new service principal  Creates a service principal with the specified authentication mode. The calling user becomes the owner of the service principal.  Returns the created service principal with credentials (client_secret). **Save the client_secret securely** - it will not be shown again.  Example:     ```json     {         \"name\": \"Batch ETL Job\",         \"description\": \"Nightly data processing\",         \"authentication_mode\": \"client_credentials\",         \"associated_user_id\": \"user:alice\",         \"inherit_permissions\": true     }     ```
     * @summary Create Service Principal
     * @param {BodyCreateServicePrincipalApiV1ServicePrincipalsPost} bodyCreateServicePrincipalApiV1ServicePrincipalsPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost: BodyCreateServicePrincipalApiV1ServicePrincipalsPost, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).createServicePrincipalApiV1ServicePrincipalsPost(bodyCreateServicePrincipalApiV1ServicePrincipalsPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a service principal  Permanently deletes the service principal from Keycloak and OpenFGA. This action cannot be undone.
     * @summary Delete Service Principal
     * @param {string} serviceId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).deleteServicePrincipalApiV1ServicePrincipalsServiceIdDelete(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a specific service principal  Returns service principal details if the current user is the owner.
     * @summary Get Service Principal
     * @param {string} serviceId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).getServicePrincipalApiV1ServicePrincipalsServiceIdGet(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List service principals owned by the current user  Returns all service principals where the current user is the owner. Does not include client secrets.
     * @summary List Service Principals
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).listServicePrincipalsApiV1ServicePrincipalsGet(hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rotate service principal secret  Generates a new client secret for the service principal. The old secret will be invalidated immediately.  **Save the new client_secret securely** - update your service configuration before the old secret expires.
     * @summary Rotate Service Principal Secret
     * @param {string} serviceId 
     * @param {HTTPAuthorizationCredentials} [hTTPAuthorizationCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId: string, hTTPAuthorizationCredentials?: HTTPAuthorizationCredentials, options?: RawAxiosRequestConfig) {
        return ServicePrincipalsApiFp(this.configuration).rotateServicePrincipalSecretApiV1ServicePrincipalsServiceIdRotateSecretPost(serviceId, hTTPAuthorizationCredentials, options).then((request) => request(this.axios, this.basePath));
    }
}



