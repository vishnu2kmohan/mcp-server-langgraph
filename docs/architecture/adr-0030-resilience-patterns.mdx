---
title: 30. Resilience Patterns
description: 'Comprehensive resilience layer with circuit breakers, retries, timeouts, and bulkhead isolation'
icon: 'file-lines'
---

## ADR-0030: Resilience Patterns for Production Systems

<Note>
**Status**: Accepted
**Date**: 2025-10-20
**Deciders**: Engineering Team
</Note>

### Context

The MCP server integrates with multiple external services that can fail or become unavailable:

- **LLM APIs** (Anthropic, OpenAI, Google Gemini) - network failures, rate limits, timeouts
- **OpenFGA** authorization service - network partitions, slow responses
- **Redis** session store - connection failures, evictions
- **Keycloak** SSO - authentication timeouts, certificate issues
- **Prometheus** metrics - query timeouts, service unavailable

#### Current Problems

<Warning>
Without proper resilience patterns, failures cascade throughout the system:
- Complete system unavailability (SLA violations)
- User-facing errors for unrelated operations
- Resource exhaustion (connection pools, memory)
- Difficult debugging and incident response
</Warning>

#### Current State

- Basic error handling with try-catch blocks
- Some retry logic but not standardized
- No circuit breakers or bulkhead isolation
- No request timeout enforcement
- Failures in external services cause immediate user errors

**Target SLA**: 99.99% uptime (&lt;0.01% error rate, &lt;52.6 minutes downtime/year)

### Decision

Implement a **comprehensive resilience layer** using four core patterns:

#### 1. Circuit Breaker Pattern

**Implementation**: Use `pybreaker` library for production-ready circuit breaker.

**Configuration**:
```python
CIRCUIT_BREAKER_FAIL_MAX = 5          # Open after 5 failures
CIRCUIT_BREAKER_TIMEOUT_DURATION = 60  # Stay open for 60s
```text
**Services Protected**:
- LLM API calls
- OpenFGA authorization
- Redis operations
- Keycloak authentication
- Prometheus queries

**States**:
- **Closed** (normal): All requests pass through
- **Open** (failing): Fail fast, return cached/default response
- **Half-Open** (testing): Allow one test request after timeout

#### Circuit Breaker State Machine

```mermaid
stateDiagram-v2
    [*] --> Closed: Initial state

    Closed --> Open: Failure threshold reached<br/>(5 consecutive failures)
    Closed --> Closed: Success (reset counter)
    Closed --> Closed: Failure (increment counter)

    Open --> HalfOpen: Timeout elapsed<br/>(60 seconds)
    Open --> Open: Request blocked<br/>(fail fast)

    HalfOpen --> Closed: Test request succeeds<br/>(reset counter)
    HalfOpen --> Open: Test request fails<br/>(back to Open)

    note right of Closed
        Normal Operation
        - All requests pass through
        - Track failure count
        - Success resets counter
    end note

    note right of Open
        Failing Fast
        - Immediate rejection
        - Return cached/default response
        - Prevent cascading failures
        - Wait for timeout
    end note

    note right of HalfOpen
        Recovery Testing
        - Allow 1 test request
        - If success → Closed
        - If failure → Open
    end note

    classDef closedState fill:#d4edda,stroke:#28a745,stroke-width:3px
    classDef openState fill:#f8d7da,stroke:#dc3545,stroke-width:3px
    classDef halfOpenState fill:#fff3cd,stroke:#ffc107,stroke-width:3px

    class Closed closedState
    class Open openState
    class HalfOpen halfOpenState
```text
**Circuit Breaker in Action**:
```mermaid
sequenceDiagram
    %%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#8dd3c7','primaryTextColor':'#1a202c','primaryBorderColor':'#2a9d8f','lineColor':'#fb8072','secondaryColor':'#fdb462','tertiaryColor':'#b3de69','actorBkg':'#8dd3c7','actorBorder':'#2a9d8f','actorTextColor':'#1a202c','actorLineColor':'#2a9d8f','signalColor':'#7cb342','signalTextColor':'#1a202c','labelBoxBkgColor':'#fdb462','labelBoxBorderColor':'#e67e22','labelTextColor':'#1a202c','noteBorderColor':'#e67e22','noteBkgColor':'#fdb462','noteTextColor':'#1a202c','activationBorderColor':'#7cb342','activationBkgColor':'#b3de69','sequenceNumberColor':'#4a5568'}}}%%
    participant App as MCP Server
    participant CB as Circuit Breaker
    participant LLM as LLM API<br/>(Anthropic)
    participant Cache as Fallback Cache

    Note over App,CB: State: Closed (Normal)
    loop First 5 requests (all fail)
        App->>CB: Call LLM API
        CB->>LLM: Forward request
        LLM-->>CB: 503 Service Unavailable
        CB->>CB: Increment failure counter<br/>(1/5, 2/5, 3/5, 4/5, 5/5)
        CB-->>App: Error (forwarded)
    end

    Note over CB: Threshold reached (5 failures)<br/>State: Closed → Open

    Note over App,CB: State: Open (Failing Fast)
    loop Next 10 requests
        App->>CB: Call LLM API
        CB->>CB: Circuit is OPEN<br/>Don't call LLM
        CB->>Cache: Get cached response
        Cache-->>CB: Cached result
        CB-->>App: Cached response ✓<br/>(fail fast, no delay)
    end

    Note over CB: Wait 60 seconds...

    Note over CB: Timeout elapsed<br/>State: Open → Half-Open

    Note over App,CB: State: Half-Open (Testing)
    App->>CB: Call LLM API (test request)
    CB->>LLM: Forward test request
    LLM-->>CB: 200 OK ✓<br/>(service recovered)
    CB->>CB: Test succeeded<br/>Reset failure counter

    Note over CB: State: Half-Open → Closed

    Note over App,CB: State: Closed (Recovered)
    loop Subsequent requests
        App->>CB: Call LLM API
        CB->>LLM: Forward request
        LLM-->>CB: 200 OK
        CB-->>App: Response
    end

```text
#### 2. Retry Logic with Exponential Backoff

**Implementation**: Use `tenacity` library for declarative retry policies.

**Configuration**:
```python
RETRY_STOP_AFTER_ATTEMPT = 3
RETRY_WAIT_EXPONENTIAL_MULTIPLIER = 1  # 1s, 2s, 4s
RETRY_WAIT_EXPONENTIAL_MAX = 10        # Cap at 10s
```text
**Retry Policies**:
- **Idempotent reads**: Retry up to 3 times (GET, queries)
- **Idempotent writes**: Retry with idempotency key
- **Non-idempotent**: No retries, fail immediately
- **Network errors**: Always retry (transient)
- **Client errors (4xx)**: Never retry (permanent)
- **Server errors (5xx)**: Retry (temporary)

#### 3. Request Timeout Enforcement

**Implementation**: Use `asyncio.timeout()` (Python 3.11+) or `asyncio.wait_for()`.

**Configuration**:
```python
DEFAULT_TIMEOUT = 30   # Global default
LLM_TIMEOUT = 60      # LLM generation
AUTH_TIMEOUT = 5      # Auth operations
DB_TIMEOUT = 10       # Database queries
HTTP_TIMEOUT = 15     # External HTTP
```text
#### 4. Bulkhead Isolation

**Implementation**: Use `asyncio.Semaphore` for resource pool limits.

**Configuration**:
```python
LLM_CONCURRENCY_LIMIT = 10      # Max 10 concurrent LLM calls
OPENFGA_CONCURRENCY_LIMIT = 50  # Max 50 concurrent auth checks
REDIS_CONCURRENCY_LIMIT = 100   # Max 100 concurrent Redis ops
DB_CONCURRENCY_LIMIT = 20       # Max 20 concurrent DB queries
```text
**Benefits**:
- Prevent resource exhaustion
- Isolate failures (LLM slowdown doesn't block auth)
- Fair resource allocation

### Graceful Degradation

| Service | Primary | Fallback | Degraded Mode |
|---------|---------|----------|---------------|
| **OpenFGA** | Check permission | Allow (fail-open) | Auth disabled warning |
| **Redis Sessions** | Distributed cache | In-memory cache | Single-instance only |
| **LLM API** | Primary model | Fallback model | Cached responses |
| **Prometheus** | Real-time metrics | Cached metrics | Stale data warning |
| **Keycloak** | SSO authentication | JWT validation | Limited features |

### Architecture

#### New Module Structure

```
resilience/
├── __init__.py                    # Public API
├── circuit_breaker.py             # Circuit breaker decorators
├── retry.py                       # Retry policy decorators
├── timeout.py                     # Timeout enforcement
├── bulkhead.py                    # Concurrency limits
├── fallback.py                    # Fallback strategies
├── metrics.py                     # Resilience metrics
└── config.py                      # Configuration
```text
#### Decorator-Based API

```python
from mcp_server_langgraph.resilience import (
    circuit_breaker,
    retry_with_backoff,
    with_timeout,
    with_bulkhead
)

@circuit_breaker(name="openfga", fail_max=5, timeout=60)
@retry_with_backoff(max_attempts=3, exponential_base=2)
@with_timeout(seconds=5)
@with_bulkhead(limit=50)
async def check_permission(user: str, resource: str) -> bool:
    """Check OpenFGA permission with full resilience"""
    async with httpx.AsyncClient() as client:
        response = await client.post(...)
        return response.json()["allowed"]
```text
### Metrics & Observability

#### New Metrics (30+)

```python
## Circuit breaker metrics
circuit_breaker_state{service, state=open|closed|half_open}
circuit_breaker_failures_total{service, error_type}
circuit_breaker_success_total{service}

## Retry metrics
retry_attempts_total{service, attempt_number}
retry_exhausted_total{service}
retry_success_after_retry_total{service}

## Timeout metrics
timeout_violations_total{service, operation}
timeout_duration_seconds{service, operation}

## Bulkhead metrics
bulkhead_rejections_total{service}
bulkhead_queue_depth{service}
bulkhead_active_operations{service}
```

#### Observability Features

- All resilience events logged with trace context
- Circuit breaker state changes trigger alerts
- Retry exhaustion logged with full context
- Timeout violations in distributed traces
- Grafana dashboard: `resilience.json`

### Consequences

#### Positive

<Check>**99.99% Uptime** - Achieve SLA with graceful degradation</Check>
<Check>**Fast Failures** - No hanging requests with circuit breakers</Check>
<Check>**Isolated Failures** - Prevent cascading issues</Check>
<Check>**Cost Optimization** - Fewer wasted API calls</Check>
<Check>**Developer Experience** - Simple decorator-based API</Check>

#### Negative

<Warning>**Complexity** - New module to maintain</Warning>
<Warning>**Configuration Overhead** - Need to tune per-service parameters</Warning>
<Warning>**Performance Overhead** - ~1-2ms latency, ~1% CPU</Warning>
<Warning>**False Positives** - Circuit breaker may open during load spikes</Warning>

#### Mitigations

1. **Start Conservative**: Lenient defaults, tighten based on metrics
2. **A/B Testing**: Roll out incrementally (10% → 100%)
3. **Feature Flags**: Enable/disable per service
4. **Monitoring**: Alert on circuit breaker state changes
5. **Documentation**: Comprehensive troubleshooting guide

### Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Availability** | 99.99% uptime | &lt;52.6 min downtime/year |
| **Performance** | P95 &lt; 500ms | Even with failures |
| **Error Rate** | &lt; 0.01% | Under normal load |
| **Recovery Time** | MTTR &lt; 5 min | Circuit breaker auto-recovery |
| **Overhead** | &lt; 2% CPU | Resilience layer impact |

### Rollout Strategy

#### Phase 1: Development (Week 1)
- Enable for all services
- Test thoroughly

#### Phase 2: Staging (Week 2)
- A/B test (50% traffic with resilience)

#### Phase 3: Production (Weeks 3-6)
- Gradual rollout: 10% → 25% → 50% → 100%
- Monitor for regressions

#### Rollback Plan
- Disable feature flag: `FF_ENABLE_RESILIENCE_PATTERNS=false`
- Remove decorators if causing issues
- Fall back to basic error handling

### Related

- [ADR-0017: Error Handling Strategy](/architecture/adr-0017-error-handling-strategy)
- [ADR-0023: Anthropic Tool Design Best Practices](/architecture/adr-0023-anthropic-tool-design-best-practices)
- [Deployment Monitoring](/deployment/monitoring)

### External Resources

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Release It! by Michael Nygard](https://pragprog.com/titles/mnee2/release-it-second-edition/)
- [pybreaker Library](https://github.com/danielfm/pybreaker)
- [tenacity Library](https://github.com/jd/tenacity)
- [Google SRE Book - Handling Overload](https://sre.google/sre-book/handling-overload/)

---

**Last Updated**: 2025-10-20
**Next Review**: 2025-11-20
