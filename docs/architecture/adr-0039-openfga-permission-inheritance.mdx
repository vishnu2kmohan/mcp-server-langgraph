---
title: "39. OpenFGA Permission Inheritance for Service Principals"
description: "Service principals (ADR-0033) need to act on behalf of users for scenarios like: - Scheduled reports generated for specific users"
icon: "file-lines"
---


# 39. OpenFGA Permission Inheritance for Service Principals

Date: 2025-01-28

## Status

Accepted

## Context

Service principals (ADR-0033) need to act on behalf of users for scenarios like:
- Scheduled reports generated for specific users
- Batch jobs processing user data with user's permissions
- Background tasks accessing user conversations
- Service-to-service calls maintaining user context

Challenge: Service principals have their own identity (`service:batch-job`) but need user permissions without password sharing or impersonation tokens.

Current OpenFGA model supports direct user→object permissions but not delegation/inheritance.

## Decision

Extend OpenFGA authorization model with **`acts_as` relation** enabling service principals to inherit permissions from associated user principals while maintaining distinct identities.

### Architecture

```
OpenFGA Authorization Model:
  service_principal (new type)
    - acts_as: [user]  ← Permission inheritance relation
    - owner: [user]    ← Who owns this service principal

Permission Check Flow:
  1. Check: service:batch-job can view conversation:thread1?
  2. Direct check: No
  3. Check acts_as: service:batch-job acts_as user:alice?
  4. If yes, check: user:alice can view conversation:thread1?
  5. If yes: Permission granted (inherited)
```

### Permission Inheritance Model

```mermaid
graph TB
    subgraph "Identity Layer"
        User[User: alice<br/>user:alice]
        SP[Service Principal<br/>service:batch-etl-job]
        Owner[Owner: bob<br/>user:bob]
    end

    subgraph "OpenFGA Tuples"
        Tuple1[acts_as Tuple<br/>service:batch-etl-job<br/>→ user:alice]
        Tuple2[owner Tuple<br/>user:bob<br/>→ service_principal:batch-etl-job]
        Tuple3[viewer Tuple<br/>user:alice<br/>→ conversation:thread1]
    end

    subgraph "Resources"
        Conv[Conversation<br/>conversation:thread1]
        Tool[Tool<br/>tool:chat]
        Org[Organization<br/>organization:acme]
    end

    %% Relationships
    SP -.->|inherits via| Tuple1
    Tuple1 -.->|acts_as| User
    Owner -->|owns| Tuple2
    Tuple2 -->|ownership| SP

    User -->|direct permission| Tuple3
    Tuple3 -->|viewer| Conv

    SP -.->|inherited permission| Conv
    User -->|can execute| Tool
    SP -.->|inherited| Tool

    User -->|member of| Org
    SP -.->|inherited| Org

    style User fill:#8dd3c7,stroke:#2a9d8f,stroke-width:2px
    style SP fill:#fdb462,stroke:#e67e22,stroke-width:2px
    style Owner fill:#8dd3c7,stroke:#2a9d8f,stroke-width:2px
    style Tuple1 fill:#fb8072,stroke:#c0392b,stroke-width:2px,stroke-dasharray: 5 5
    style Tuple2 fill:#bebada,stroke:#8e44ad,stroke-width:2px
    style Tuple3 fill:#b3de69,stroke:#7cb342,stroke-width:2px
    style Conv fill:#ffffb3,stroke:#f39c12,stroke-width:2px
    style Tool fill:#ffffb3,stroke:#f39c12,stroke-width:2px
    style Org fill:#80b1d3,stroke:#3498db,stroke-width:2px
```

**Permission Check Flow with Inheritance**:
```mermaid
sequenceDiagram
    participant App as MCP Server
    participant FGA as OpenFGA
    participant Tuples as Tuple Store

    Note over App,FGA: Request: Can service:batch-etl-job view conversation:thread1?

    App->>FGA: Check(service:batch-etl-job, viewer, conversation:thread1)

    Note over FGA: Step 1: Direct Permission Check
    FGA->>Tuples: Find direct tuple<br/>user=service:batch-etl-job<br/>relation=viewer<br/>object=conversation:thread1
    Tuples-->>FGA: Not found

    Note over FGA: Step 2: Check acts_as Relationship
    FGA->>Tuples: Find acts_as tuple<br/>user=service:batch-etl-job<br/>relation=acts_as
    Tuples-->>FGA: Found: service:batch-etl-job acts_as user:alice

    Note over FGA: Step 3: Check Inherited Permission
    FGA->>FGA: Recursive check<br/>Check(user:alice, viewer, conversation:thread1)
    FGA->>Tuples: Find tuple<br/>user=user:alice<br/>relation=viewer<br/>object=conversation:thread1
    Tuples-->>FGA: Found: user:alice → viewer → conversation:thread1

    Note over FGA: Step 4: Grant Permission via Inheritance
    FGA-->>App: Allowed (inherited from user:alice)

    App->>App: Log action<br/>Actor: service:batch-etl-job<br/>Effective User: user:alice<br/>Action: view conversation:thread1

    classDef appStyle fill:#b3de69,stroke:#7cb342,stroke-width:2px
    classDef fgaStyle fill:#fb8072,stroke:#c0392b,stroke-width:2px
    classDef tupleStyle fill:#bebada,stroke:#8e44ad,stroke-width:2px

    class App appStyle
    class FGA fgaStyle
    class Tuples tupleStyle
```

### Core Principles

1. **Explicit Association**: `acts_as` tuples created deliberately (not automatic)
2. **Transitive Permissions**: Service inherits all user permissions
3. **Distinct Identity**: Service actions logged as service (not user)
4. **Audit Trail**: Both service and associated user tracked
5. **Revocable**: Disabling user revokes service permissions
6. **Ownership Tracking**: Services have owners for management

### OpenFGA Model Extension

**New Type**:
```typescript
type service_principal
  relations
    define owner: [user]
    define acts_as: [user]
    define viewer: owner
    define editor: owner
```

**Relationship Tuples**:
```python
[
    # Service inherits permissions from user
    {
        "user": "service:batch-etl-job",
        "relation": "acts_as",
        "object": "user:alice"
    },
    # User owns service principal
    {
        "user": "user:bob",
        "relation": "owner",
        "object": "service_principal:batch-etl-job"
    },
    # Example user permission (inherited by service)
    {
        "user": "user:alice",
        "relation": "viewer",
        "object": "conversation:thread1"
    }
]
```

### Permission Check Implementation

**Enhanced Authorization** (`src/mcp_server_langgraph/auth/openfga.py`):
```python
async def check_permission(
    user_id: str,
    relation: str,
    object: str,
    openfga_client
) -> bool:
    """Check permission with acts_as support"""

    # 1. Direct permission check
    if await openfga_client.check(user_id, relation, object):
        return True

    # 2. If service principal, check inherited permissions
    if user_id.startswith("service:"):
        # Get associated users via acts_as
        acts_as_query = {
            "user": user_id,
            "relation": "acts_as",
            "object_type": "user"
        }
        associated_users = await openfga_client.list_objects(acts_as_query)

        # Check if any associated user has permission
        for associated_user in associated_users:
            if await openfga_client.check(associated_user, relation, object):
                # Log: service:batch-job accessed resource via user:alice
                logger.info(
                    f"{user_id} accessed {object} via inherited permission from {associated_user}"
                )
                return True

    return False
```

### Configuration

```bash
# OpenFGA Permission Inheritance
OPENFGA_PERMISSION_INHERITANCE_ENABLED=true
OPENFGA_LOG_INHERITED_ACCESS=true  # Log when service uses inherited permissions
OPENFGA_CACHE_ACTS_AS_RELATIONS=true  # Cache acts_as lookups (5 min TTL)
```

## Consequences

### Positive Consequences
- Service principals can act on behalf of users (no password sharing)
- Clear audit trail (service identity + associated user)
- Flexible permissions (service can act as multiple users)
- Revocation propagates (disable user → service loses permissions)
- Standard ReBAC model (no custom authorization logic)

### Negative Consequences
- Additional authorization complexity (extra tuple lookups)
- Performance impact (two permission checks instead of one)
- Potential permission confusion (non-obvious inheritance)
- Authorization model more complex (additional relation types)

### Mitigation Strategies
- Cache `acts_as` relationships (5-min TTL, high hit rate)
- Clear logging of inherited access
- UI showing effective permissions for service principals
- Documentation with clear examples

## Alternatives Considered

1. **Token Impersonation**: Rejected - complex OAuth2 token exchange, admin credentials required
2. **Shared Credentials**: Rejected - security risk, poor audit trail
3. **Copy Permissions**: Rejected - sync overhead, permission drift
4. **Service-Specific Permissions**: Rejected - doesn't support user context

## Implementation

**OpenFGA Model Update** (`src/mcp_server_langgraph/auth/openfga.py:287-377`):
```python
def get_model_definition() -> dict:
    return {
        "schema_version": "1.2",
        "type_definitions": [
            # ... existing types ...
            {
                "type": "service_principal",
                "relations": {
                    "owner": {"this": {}},
                    "acts_as": {"this": {}},
                    "viewer": {"computedUserset": {"object": "", "relation": "owner"}},
                    "editor": {"computedUserset": {"object": "", "relation": "owner"}}
                }
            }
        ]
    }
```

**Tuple Creation** (in ServicePrincipalManager):
```python
async def associate_with_user(
    self, service_id: str, user_id: str, inherit_permissions: bool = True
):
    if inherit_permissions:
        await openfga_client.write_tuples([{
            "user": f"service:{service_id}",
            "relation": "acts_as",
            "object": user_id
        }])
```

**Authorization Check Enhancement**:
```python
# In middleware or route handlers
allowed = await check_permission(
    user_id="service:batch-job",
    relation="viewer",
    object="conversation:thread1",
    openfga_client=openfga_client
)
# Returns True if service:batch-job acts_as user who has viewer permission
```

## References

- OpenFGA Integration: `src/mcp_server_langgraph/auth/openfga.py`
- Service Principal Manager: `src/mcp_server_langgraph/auth/service_principal.py` (to be created)
- Related ADRs: [ADR-0002](0002-openfga-authorization.md), [ADR-0033](0033-service-principal-design.md)
- External: [OpenFGA Docs](https://openfga.dev/docs), [ReBAC](https://openfga.dev/docs/modeling/building-blocks/usersets#the-basics)
