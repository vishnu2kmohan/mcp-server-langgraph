---
title: 34. API Key to JWT Exchange Pattern
description: 'Legacy systems and simple integrations use API keys for authentication due to simplicity and stateless nature. However, our architecture standardiz...'
icon: 'file-lines'
---


Date: 2025-01-28

### Status

Accepted

### Context

Legacy systems and simple integrations use API keys for authentication due to simplicity and stateless nature. However, our architecture standardizes on JWTs (ADR-0032) for consistent authentication and authorization. This creates tension between legacy support and JWT standardization.

Current challenges:
- Kong stores API keys separately from Keycloak (inconsistent)
- No user attribution for API key requests
- API keys don't integrate with OpenFGA authorization
- Cannot enforce same permission model as user JWTs

### Decision

We will implement an **API Key to JWT Exchange Pattern** where API keys are stored in Keycloak and exchanged for short-lived JWTs on each request.

#### Architecture

```
Client (API Key) → Kong (custom plugin) → Keycloak (validate & exchange)
  → JWT → Replace header → MCP Server (validates JWT normally)
```

#### API Key to JWT Exchange Flow

```mermaid
sequenceDiagram
    %%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#8dd3c7','primaryTextColor':'#1a202c','primaryBorderColor':'#2a9d8f','lineColor':'#fb8072','secondaryColor':'#fdb462','tertiaryColor':'#b3de69','actorBkg':'#8dd3c7','actorBorder':'#2a9d8f','actorTextColor':'#1a202c','actorLineColor':'#2a9d8f','signalColor':'#7cb342','signalTextColor':'#1a202c','labelBoxBkgColor':'#fdb462','labelBoxBorderColor':'#e67e22','labelTextColor':'#1a202c','noteBorderColor':'#e67e22','noteBkgColor':'#fdb462','noteTextColor':'#1a202c','activationBorderColor':'#7cb342','activationBkgColor':'#b3de69','sequenceNumberColor':'#4a5568'}}}%%
    participant Client as Client<br/>(API Key Holder)
    participant Kong as Kong Gateway<br/>(Custom Plugin)
    participant Cache as Redis Cache<br/>(Exchange Cache)
    participant KC as Keycloak<br/>Identity Provider
    participant App as MCP Server
    participant FGA as OpenFGA

    Note over Client,Kong: Client sends API Key
    Client->>Kong: GET /api/tools<br/>Authorization: ApiKey sk_live_abc123

    Note over Kong,Cache: Check cache first (5-min TTL)
    Kong->>Cache: Get cached JWT for key hash
    Cache-->>Kong: Cache miss

    Note over Kong,KC: Validate API Key and Exchange for JWT
    Kong->>Kong: Hash API key with bcrypt
    Kong->>KC: POST /validate-api-key<br/>key_hash: $2b$12$hash
    KC->>KC: Query user attributes<br/>Find matching apiKeys array
    KC->>KC: Validate expiration<br/>Check key active status
    KC-->>Kong: User found: alice<br/>User ID: user:alice

    Kong->>KC: POST /token<br/>grant_type=client_credentials<br/>for user:alice
    KC-->>Kong: JWT Token<br/>sub: user:alice<br/>TTL: 15 min

    Note over Kong,Cache: Cache the exchange result
    Kong->>Cache: SET key_hash → JWT<br/>TTL: 300 seconds
    Cache-->>Kong: Cached

    Note over Kong,App: Replace API Key with JWT
    Kong->>Kong: Replace header<br/>Authorization: Bearer <JWT>
    Kong->>App: GET /api/tools<br/>Authorization: Bearer <JWT>

    Note over App,FGA: Standard JWT validation and authz
    App->>App: Validate JWT signature<br/>Check expiration
    App->>FGA: Check(user:alice, execute, tool:chat)
    FGA-->>App: Allowed
    App-->>Kong: Response

    Kong-->>Client: Response<br/>(API Key transparent)

    Note over Client: Client only sees standard HTTP response

```
**Subsequent Requests (Cached)**:
```mermaid
sequenceDiagram
    %%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#8dd3c7','primaryTextColor':'#1a202c','primaryBorderColor':'#2a9d8f','lineColor':'#fb8072','secondaryColor':'#fdb462','tertiaryColor':'#b3de69','actorBkg':'#8dd3c7','actorBorder':'#2a9d8f','actorTextColor':'#1a202c','actorLineColor':'#2a9d8f','signalColor':'#7cb342','signalTextColor':'#1a202c','labelBoxBkgColor':'#fdb462','labelBoxBorderColor':'#e67e22','labelTextColor':'#1a202c','noteBorderColor':'#e67e22','noteBkgColor':'#fdb462','noteTextColor':'#1a202c','activationBorderColor':'#7cb342','activationBkgColor':'#b3de69','sequenceNumberColor':'#4a5568'}}}%%
    participant Client as Client
    participant Kong as Kong Gateway
    participant Cache as Redis Cache
    participant App as MCP Server

    Note over Client,Cache: Fast path with cache hit
    Client->>Kong: Request + API Key
    Kong->>Cache: Get cached JWT
    Cache-->>Kong: JWT (cache hit)
    Kong->>Kong: Replace header with JWT
    Kong->>App: Request + JWT
    App-->>Kong: Response
    Kong-->>Client: Response

    Note over Kong,Cache: ~5ms latency (vs 20-50ms without cache)

```
#### Core Principles

1. **Exchange, Not Replace**: API keys exchanged for JWTs, not standalone auth
2. **Keycloak Storage**: API keys stored in Keycloak user/client attributes
3. **Transparent to Backend**: MCP Server only sees JWTs
4. **User Attribution**: API keys linked to user or service principal identity
5. **Standard Validation**: JWT validation applies same rules
6. **Rotation Support**: Keys can be rotated without changing client code

#### API Key Storage in Keycloak

**User Attributes**:
```json
{
  "attributes": {
    "apiKeys": ["key:abc123:$2b$12$hash", "key:xyz789:$2b$12$hash"],
    "apiKey_abc123_name": "Production Key",
    "apiKey_abc123_created": "2025-01-28T00:00:00Z",
    "apiKey_abc123_expiresAt": "2026-01-28T00:00:00Z"
  }
}
```
#### Exchange Flow

1. Client → Kong: `Authorization: ApiKey sk_live_abc123xyz`
2. Kong Plugin: Extract key, hash with bcrypt, query Keycloak for match
3. If found: Call Keycloak token endpoint, get JWT
4. Replace header: `Authorization: Bearer <JWT>`
5. Kong → MCP Server: Standard JWT validation

#### Configuration

```bash
API_KEY_ENABLED=true
API_KEY_STORAGE=keycloak
API_KEY_HASH_ALGORITHM=bcrypt
API_KEY_PREFIX=sk_live_
API_KEY_MAX_PER_USER=5
API_KEY_EXCHANGE_CACHE_TTL=300  # 5 min cache
```
### Consequences

#### Positive Consequences
- JWT standardization maintained, consistent authorization
- User attribution, centralized management in Keycloak
- Audit trail, rotation support, expiration support

#### Negative Consequences
- Custom Kong plugin (Lua development)
- Exchange latency (20-50ms Keycloak call)
- Cache complexity, migration required

#### Mitigation Strategies
- Cache key→user mappings (5-min TTL, >90% hit rate target)
- Connection pooling to Keycloak
- Gradual migration with fallback period

### Alternatives Considered

1. **Standalone API Keys**: Rejected - violates JWT standardization
2. **Kong-Only Storage**: Rejected - inconsistent with Keycloak authority
3. **No API Keys**: Rejected - too disruptive for legacy integrations
4. **Long-Lived JWTs**: Rejected - cannot revoke, security risk

### Implementation

**APIKeyManager** (`src/mcp_server_langgraph/auth/api_keys.py`):
```python
class APIKeyManager:
    async def create_api_key(self, user_id, name, expires_days=365):
        api_key = self.generate_api_key()  # sk_live_...
        key_hash = bcrypt.hashpw(api_key.encode(), bcrypt.gensalt())
        # Store in Keycloak user attributes
```
**Kong Plugin** (`deployments/kong/custom-plugins/kong-apikey-jwt-exchange.lua`):
```lua
-- Extract API key, validate with Keycloak, cache JWT, replace header
```

**API Endpoints** (`src/mcp_server_langgraph/api/api_keys.py`):
- POST `/api/v1/api-keys` - Create
- POST `/api/v1/api-keys/validate` - Validate & exchange (Kong calls this)
- GET `/api/v1/api-keys` - List
- DELETE `/api/v1/api-keys/{key_id}` - Revoke

### References

- Related ADRs: [ADR-0031](/architecture/adr-0031-keycloak-authoritative-identity), [ADR-0032](/architecture/adr-0032-jwt-standardization), [ADR-0035](/architecture/adr-0035-kong-jwt-validation)
- External: [API Key Best Practices](https://cloud.google.com/endpoints/docs/openapi/when-why-api-key), [bcrypt](https://en.wikipedia.org/wiki/Bcrypt)
