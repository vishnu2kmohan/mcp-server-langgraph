---
title: "Service Principal Design and Authentication Modes"
description: "Service Principal Design and Authentication Modes"
icon: "file-lines"
---

# 33. Service Principal Design and Authentication Modes

Date: 2025-01-28

## Status

Accepted

## Context

Machine-to-machine authentication, batch jobs, streaming tasks, and background processes require persistent identity and long-lived credentials that differ from human user patterns. Challenges include:

- **Long-Running Tasks**: OAuth2 JWTs have short lifespans (15 min) unsuitable for batch jobs running hours/days
- **Streaming Sessions**: WebSocket connections need credentials persisting throughout session
- **Permission Attribution**: Automated processes need clear ownership and auditable identity
- **Permission Inheritance**: Background jobs often need to act on behalf of specific users
- **Credential Management**: Services need programmatic authentication without human interaction

Current system only supports human user authentication with 15-minute token lifetimes.

## Decision

We will implement **Service Principals as first-class identities** with two authentication modes and optional user association for permission inheritance.

### Core Principles

1. **First-Class Identity**: Service principals distinct from users in authorization model
2. **Dual Authentication**: Support OAuth2 client credentials AND service account users
3. **Optional User Association**: Service principals can act on behalf of specific users
4. **Permission Inheritance**: Can inherit permissions from associated user principals
5. **Long-Lived Credentials**: Support 30-day refresh tokens for persistent tasks
6. **Keycloak-Issued**: All service principal tokens issued by Keycloak (JWT standard)

### Architecture

**Service Principal Identity Format**:
- Subject (sub) claim: `service:<client-id>` (e.g., `service:batch-etl-job`)
- OpenFGA Object: `service_principal:batch-etl-job`

### Service Principal Authentication Flow

```mermaid
sequenceDiagram
    participant SP as Service Principal<br/>(batch-etl-job)
    participant KC as Keycloak<br/>Identity Provider
    participant App as MCP Server
    participant FGA as OpenFGA<br/>Authorization
    participant User as Associated User<br/>(alice)

    Note over SP,KC: Mode 1: Client Credentials Flow (Preferred)
    SP->>KC: POST /token<br/>grant_type=client_credentials<br/>client_id + client_secret
    KC->>KC: Validate credentials<br/>Check service account enabled
    KC-->>SP: JWT Token<br/>sub: service:batch-etl-job<br/>TTL: 30 days

    Note over SP,App: Service Principal makes API request
    SP->>App: API Request + JWT
    App->>App: Validate JWT signature
    App->>KC: Verify token (optional)
    KC-->>App: Token valid

    Note over App,FGA: Permission Check with Inheritance
    App->>FGA: Check(service:batch-etl-job, execute, tool:chat)
    FGA->>FGA: Find acts_as relationship<br/>service:batch-etl-job → user:alice
    FGA->>FGA: Check inherited permissions<br/>user:alice → tool:chat
    FGA-->>App: Allowed (via inheritance)

    App-->>SP: Response with data

    Note over SP,User: Audit Trail
    App->>App: Log action<br/>Principal: service:batch-etl-job<br/>Effective User: alice

    classDef serviceStyle fill:#fdb462,stroke:#e67e22,stroke-width:2px
    classDef authStyle fill:#bebada,stroke:#8e44ad,stroke-width:2px
    classDef appStyle fill:#b3de69,stroke:#7cb342,stroke-width:2px
    classDef fgaStyle fill:#fb8072,stroke:#c0392b,stroke-width:2px
    classDef userStyle fill:#8dd3c7,stroke:#2a9d8f,stroke-width:2px

    class SP serviceStyle
    class KC authStyle
    class App appStyle
    class FGA fgaStyle
    class User userStyle
```

### Authentication Modes

#### Mode 1: Client Credentials Flow (Preferred)
**Use Case**: Dedicated services, microservices, batch jobs

**Keycloak Configuration**:
```json
{
  "clientId": "batch-etl-job",
  "serviceAccountsEnabled": true,
  "attributes": {
    "associatedUserId": "user:alice",
    "inheritPermissions": "true",
    "owner": "user:bob"
  }
}
```

**Authentication**:
```python
response = await httpx.post(token_endpoint, data={
    "grant_type": "client_credentials",
    "client_id": "batch-etl-job",
    "client_secret": "service-secret"
})
```

#### Mode 2: Service Account User (Alternative)
**Use Case**: Legacy systems migration, mixed authentication needs

**Keycloak Configuration**:
```json
{
  "username": "svc_batch_etl",
  "attributes": {
    "serviceAccount": "true",
    "associatedUserId": "user:alice",
    "inheritPermissions": "true"
  }
}
```

### User Association and Permission Inheritance

**OpenFGA Tuples**:
```python
[
    # Service acts as user (permission inheritance)
    {"user": "service:batch-etl-job", "relation": "acts_as", "object": "user:alice"},
    # User owns service principal
    {"user": "user:bob", "relation": "owner", "object": "service_principal:batch-etl-job"}
]
```

**Permission Check**: Service inherits user permissions via `acts_as` relationship.

### Configuration

```bash
ENABLE_SERVICE_PRINCIPALS=true
SERVICE_PRINCIPAL_DEFAULT_TTL=2592000  # 30 days
SERVICE_PRINCIPAL_REFRESH_TOKEN_LIFESPAN=2592000
SERVICE_PRINCIPAL_INHERIT_PERMISSIONS=true
SERVICE_PRINCIPAL_ROTATE_SECRET_DAYS=90
```

## Consequences

### Positive Consequences
- Long-running support (30-day tokens), clear attribution
- Permission delegation without password sharing
- Audit trail, flexible authentication (two modes)
- Security isolation, ownership tracking

### Negative Consequences
- Implementation complexity (two modes)
- Keycloak configuration expertise required
- OpenFGA model changes, additional secrets to manage
- Permission inheritance may be non-obvious

### Mitigation Strategies
- High-level SDK abstracting modes, clear documentation
- Automated secret rotation (90 days), IP whitelisting
- Audit reports showing effective permissions

## Alternatives Considered

1. **User Accounts Only**: Rejected - conflates humans with machines, poor audit trail
2. **API Keys Only**: Rejected - violates JWT standardization
3. **Client Credentials Only**: Rejected - lacks flexibility for legacy systems
4. **Impersonation Flow**: Rejected - security risk of admin credentials in services

## Implementation

**ServicePrincipalManager** (`src/mcp_server_langgraph/auth/service_principal.py`):
```python
class ServicePrincipalManager:
    async def create_service_principal(
        self, service_id, name, authentication_mode,
        associated_user_id=None, inherit_permissions=False
    ) -> ServicePrincipal:
        # Create in Keycloak (client or user)
        # Sync to OpenFGA with acts_as tuples
```

**API Endpoints** (`src/mcp_server_langgraph/api/service_principals.py`):
- POST `/api/v1/service-principals` - Create
- GET `/api/v1/service-principals` - List owned
- POST `/api/v1/service-principals/{id}/rotate-secret` - Rotate
- DELETE `/api/v1/service-principals/{id}` - Delete

## References

- Implementation: `src/mcp_server_langgraph/auth/service_principal.py` (to be created)
- API: `src/mcp_server_langgraph/api/service_principals.py` (to be created)
- Related ADRs: [ADR-0031](0031-keycloak-authoritative-identity.md), [ADR-0032](0032-jwt-standardization.md), [ADR-0036](0036-hybrid-session-model.md), [ADR-0039](0039-openfga-permission-inheritance.md)
- External: [OAuth 2.0 Client Credentials](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4), [Keycloak Service Accounts](https://www.keycloak.org/docs/latest/server_admin/#_service_accounts)
