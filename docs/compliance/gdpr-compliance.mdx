---
title: 'GDPR Compliance Guide'
description: 'Complete guide for deploying GDPR-compliant AI agents with MCP Server and LangGraph in the European Union'
icon: 'scale-balanced'
seoTitle: "GDPR Compliance for AI Agents - MCP Server Guide"
seoDescription: "Deploy GDPR-compliant AI agents in the EU. Complete guide covering data protection, privacy rights, DPIAs, and compliance checklist."
keywords: ["GDPR compliance", "data protection", "EU privacy", "GDPR AI", "data processing"]
contentType: "guide"
---

## Overview

This guide provides a comprehensive framework for deploying **GDPR-compliant** AI agents using MCP Server with LangGraph in the European Union. It covers technical controls, data protection requirements, and documentation required for processing personal data under the General Data Protection Regulation (GDPR).

<Warning>
**Legal Disclaimer**: This guide provides technical implementation guidance but is not legal advice. Consult with your Data Protection Officer (DPO) and legal counsel before processing personal data in the EU. GDPR compliance requires both technical measures and organizational policies.
</Warning>

---

## GDPR Readiness Overview

MCP Server with LangGraph provides the **technical foundation** for GDPR compliance, but achieving full compliance requires:

1. **Lawful Basis for Processing** (Consent, Contract, Legal Obligation, etc.)
2. **Data Protection Principles** (Purpose limitation, data minimization, etc.)
3. **Data Subject Rights** (Access, rectification, erasure, portability, etc.)
4. **Technical and Organizational Measures** (Encryption, pseudonymization, etc.)
5. **Data Protection Impact Assessment** (DPIA) for high-risk processing
6. **Data Processing Agreements** (DPAs) with processors
7. **Breach Notification Procedures** (72-hour notification requirement)

**Status**: MCP Server is **GDPR-ready** (technical controls in place). You must implement organizational measures based on your specific processing activities.

---

## Data Protection Principles (Article 5)

### 1. Lawfulness, Fairness, and Transparency

**Implementation:**

```python
# src/models/consent.py
from enum import Enum
from datetime import datetime
from pydantic import BaseModel

class LawfulBasis(str, Enum):
    """GDPR Article 6 lawful bases for processing."""
    CONSENT = "consent"  # Article 6(1)(a)
    CONTRACT = "contract"  # Article 6(1)(b)
    LEGAL_OBLIGATION = "legal_obligation"  # Article 6(1)(c)
    VITAL_INTERESTS = "vital_interests"  # Article 6(1)(d)
    PUBLIC_TASK = "public_task"  # Article 6(1)(e)
    LEGITIMATE_INTERESTS = "legitimate_interests"  # Article 6(1)(f)

class ConsentRecord(BaseModel):
    """Record of user consent for GDPR compliance."""
    user_id: str
    lawful_basis: LawfulBasis
    purpose: str
    consent_given: bool
    consent_timestamp: datetime
    consent_version: str  # Privacy policy version
    consent_method: str  # e.g., "web_form", "api", "explicit_opt_in"
    can_withdraw: bool
    withdrawal_method: str | None

    # Special categories (Article 9)
    special_category_data: bool = False
    special_category_consent: bool | None = None

class ConsentManager:
    """Manage user consent for GDPR compliance."""

    async def record_consent(
        self,
        user_id: str,
        purpose: str,
        lawful_basis: LawfulBasis,
        privacy_policy_version: str
    ) -> ConsentRecord:
        """Record user consent with full audit trail."""
        consent = ConsentRecord(
            user_id=user_id,
            lawful_basis=lawful_basis,
            purpose=purpose,
            consent_given=True,
            consent_timestamp=datetime.utcnow(),
            consent_version=privacy_policy_version,
            consent_method="explicit_opt_in",
            can_withdraw=True,
            withdrawal_method="account_settings"
        )

        await self.db.consents.insert_one(consent.dict())
        await self.audit_log.info(
            event="consent_recorded",
            user_id=user_id,
            purpose=purpose,
            lawful_basis=lawful_basis
        )

        return consent

    async def check_consent(self, user_id: str, purpose: str) -> bool:
        """Verify user has valid consent for processing purpose."""
        consent = await self.db.consents.find_one({
            "user_id": user_id,
            "purpose": purpose,
            "consent_given": True
        })

        return consent is not None

    async def withdraw_consent(self, user_id: str, purpose: str):
        """Allow user to withdraw consent (Article 7(3))."""
        await self.db.consents.update_one(
            {"user_id": user_id, "purpose": purpose},
            {
                "$set": {
                    "consent_given": False,
                    "withdrawal_timestamp": datetime.utcnow()
                }
            }
        )

        await self.audit_log.info(
            event="consent_withdrawn",
            user_id=user_id,
            purpose=purpose
        )

        # Stop processing immediately
        await self.stop_processing_for_purpose(user_id, purpose)
```

---

### 2. Purpose Limitation (Article 5(1)(b))

**Requirement**: Personal data collected for specified, explicit, and legitimate purposes.

```python
# config/processing_purposes.yaml
processing_purposes:
  # Define explicit purposes for data processing
  - id: "agent_interaction"
    name: "AI Agent Interactions"
    description: "Process user queries to provide AI agent responses"
    lawful_basis: "consent"
    data_collected:
      - user_query
      - conversation_history
      - user_preferences
    retention_period: "30_days"
    storage_location: "EU"

  - id: "service_improvement"
    name: "Service Quality Improvement"
    description: "Analyze usage patterns to improve agent responses"
    lawful_basis: "legitimate_interests"
    data_collected:
      - aggregated_usage_stats
      - error_rates
      - response_times
    retention_period: "365_days"
    storage_location: "EU"
    legitimate_interest_assessment: "docs/gdpr/lia-service-improvement.pdf"

  - id: "legal_compliance"
    name: "Legal and Regulatory Compliance"
    description: "Maintain records for legal obligations"
    lawful_basis: "legal_obligation"
    data_collected:
      - audit_logs
      - security_events
    retention_period: "7_years"
    storage_location: "EU"
```

---

### 3. Data Minimization (Article 5(1)(c))

**Requirement**: Personal data shall be adequate, relevant, and limited to what is necessary.

```python
# src/middleware/data_minimization.py
from typing import Dict, Any, List

class DataMinimization:
    """Implement GDPR data minimization principle."""

    # Define minimum required fields per purpose
    MINIMAL_DATA = {
        "agent_interaction": [
            "query",  # User's question
            "session_id",  # For conversation continuity
            "timestamp"  # For rate limiting
        ],
        "service_improvement": [
            "response_time",  # Performance metrics
            "error_code",  # Error tracking
            "model_used"  # Model performance comparison
        ]
    }

    def minimize_data(
        self,
        data: Dict[str, Any],
        purpose: str
    ) -> Dict[str, Any]:
        """Remove unnecessary fields based on processing purpose."""
        allowed_fields = self.MINIMAL_DATA.get(purpose, [])

        minimized = {
            key: value
            for key, value in data.items()
            if key in allowed_fields
        }

        # Log if data was stripped (for transparency)
        if len(minimized) < len(data):
            removed_fields = set(data.keys()) - set(minimized.keys())
            self.audit_log.info(
                event="data_minimized",
                purpose=purpose,
                removed_fields=list(removed_fields)
            )

        return minimized

    def anonymize_for_analytics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Anonymize data for analytics (no longer personal data)."""
        return {
            "session_hash": self.hash_session_id(data.get("session_id")),
            "response_time_ms": data.get("response_time"),
            "model": data.get("model"),
            "status": data.get("status"),
            # Remove all personally identifiable information
        }
```

---

### 4. Accuracy (Article 5(1)(d))

**Requirement**: Personal data shall be accurate and kept up to date.

```python
# src/services/data_accuracy.py
from datetime import datetime, timedelta

class DataAccuracy:
    """Ensure personal data accuracy per GDPR."""

    async def validate_data_freshness(self, user_id: str):
        """Check if user data needs revalidation."""
        user = await self.db.users.find_one({"id": user_id})

        # Require revalidation after 12 months
        if user["last_verified"] < datetime.utcnow() - timedelta(days=365):
            await self.request_data_revalidation(user_id)

    async def request_data_revalidation(self, user_id: str):
        """Ask user to confirm data accuracy."""
        await self.notifications.send(
            user_id=user_id,
            type="data_verification",
            message="Please verify your personal information is accurate",
            action_url="/account/verify"
        )

    async def update_data(self, user_id: str, updated_data: Dict[str, Any]):
        """Update personal data with accuracy verification."""
        # Validate data format
        validated = self.validate_data_format(updated_data)

        # Update with version tracking
        await self.db.users.update_one(
            {"id": user_id},
            {
                "$set": {
                    **validated,
                    "last_updated": datetime.utcnow(),
                    "last_verified": datetime.utcnow(),
                    "updated_by": user_id
                }
            }
        )

        await self.audit_log.info(
            event="personal_data_updated",
            user_id=user_id,
            fields_updated=list(validated.keys())
        )
```

---

### 5. Storage Limitation (Article 5(1)(e))

**Requirement**: Personal data kept only as long as necessary for the purposes.

```yaml
# config/retention_policy.yaml
retention_policy:
  # Automatic deletion schedules
  data_types:
    - type: "conversation_history"
      retention: "30_days"
      deletion_method: "automatic"
      legal_basis: "no_longer_necessary"

    - type: "user_preferences"
      retention: "until_account_deletion"
      deletion_method: "on_request"
      legal_basis: "consent_withdrawn"

    - type: "audit_logs"
      retention: "7_years"
      deletion_method: "automatic"
      legal_basis: "legal_obligation"

    - type: "aggregated_analytics"
      retention: "indefinite"
      deletion_method: "not_applicable"
      legal_basis: "anonymized_no_personal_data"

  # Automated cleanup jobs
  cleanup_schedule: "daily"
  cleanup_time: "02:00_UTC"
```

**Implementation:**

```python
# src/jobs/retention_cleanup.py
from datetime import datetime, timedelta

class RetentionCleanup:
    """Automated data deletion per GDPR retention policy."""

    async def run_cleanup(self):
        """Run scheduled data cleanup job."""
        retention_config = await self.load_retention_policy()

        for data_type_config in retention_config["data_types"]:
            if data_type_config["deletion_method"] == "automatic":
                await self.cleanup_expired_data(data_type_config)

    async def cleanup_expired_data(self, config: Dict[str, Any]):
        """Delete data past retention period."""
        data_type = config["type"]
        retention_days = self.parse_retention_period(config["retention"])

        cutoff_date = datetime.utcnow() - timedelta(days=retention_days)

        # Find expired records
        expired = await self.db[data_type].count_documents({
            "created_at": {"$lt": cutoff_date}
        })

        if expired > 0:
            # Delete expired records
            result = await self.db[data_type].delete_many({
                "created_at": {"$lt": cutoff_date}
            })

            await self.audit_log.info(
                event="automated_data_deletion",
                data_type=data_type,
                records_deleted=result.deleted_count,
                retention_period=config["retention"],
                legal_basis=config["legal_basis"]
            )
```

---

## Data Subject Rights (Chapter III)

### 1. Right of Access (Article 15)

**Implementation:**

```python
# src/api/data_subject_rights.py
from fastapi import APIRouter, Depends
from typing import Dict, Any

router = APIRouter()

@router.get("/api/v1/gdpr/data-export")
async def export_personal_data(
    user_id: str = Depends(get_current_user)
) -> Dict[str, Any]:
    """Export all personal data (Right of Access - Article 15)."""

    # Collect all personal data
    user_data = {
        "user_profile": await db.users.find_one({"id": user_id}),
        "conversation_history": await db.conversations.find(
            {"user_id": user_id}
        ).to_list(None),
        "preferences": await db.preferences.find_one({"user_id": user_id}),
        "consent_records": await db.consents.find(
            {"user_id": user_id}
        ).to_list(None),
        "audit_log": await db.audit_logs.find(
            {"user.id": user_id}
        ).to_list(1000)  # Last 1000 events
    }

    # Include processing information (Article 15(1))
    processing_info = {
        "purposes": await get_processing_purposes(user_id),
        "categories": ["user_queries", "preferences", "usage_analytics"],
        "recipients": ["LLM providers (with DPA)", "Cloud infrastructure (GCP)"],
        "retention_periods": await get_retention_periods(),
        "data_sources": ["direct_user_input", "automated_collection"],
        "automated_decision_making": {
            "exists": True,
            "logic": "LLM-based query routing",
            "significance": "Determines which specialized agent handles query",
            "consequences": "Affects response quality and latency"
        }
    }

    # Generate portable export (machine-readable)
    export_package = {
        "export_date": datetime.utcnow().isoformat(),
        "data_subject": user_id,
        "personal_data": user_data,
        "processing_information": processing_info,
        "format": "JSON",
        "gdpr_article": "Article_15_Right_of_Access"
    }

    # Audit the access request
    await audit_log.info(
        event="data_export_requested",
        user_id=user_id,
        export_size_bytes=len(json.dumps(export_package))
    )

    return export_package
```

---

### 2. Right to Rectification (Article 16)

```python
@router.patch("/api/v1/gdpr/rectify-data")
async def rectify_personal_data(
    corrections: Dict[str, Any],
    user_id: str = Depends(get_current_user)
):
    """Allow user to correct inaccurate personal data (Article 16)."""

    # Validate corrections
    validated = validate_data_format(corrections)

    # Apply corrections
    await db.users.update_one(
        {"id": user_id},
        {
            "$set": {
                **validated,
                "last_updated": datetime.utcnow(),
                "last_verified": datetime.utcnow()
            }
        }
    )

    await audit_log.info(
        event="data_rectified",
        user_id=user_id,
        fields_corrected=list(validated.keys())
    )

    return {"status": "data_rectified", "updated_fields": list(validated.keys())}
```

---

### 3. Right to Erasure / Right to be Forgotten (Article 17)

```python
@router.delete("/api/v1/gdpr/erase-data")
async def erase_personal_data(
    user_id: str = Depends(get_current_user),
    reason: str = None
):
    """Delete all personal data (Right to Erasure - Article 17)."""

    # Verify erasure is applicable
    if not await can_erase_data(user_id, reason):
        raise HTTPException(
            status_code=400,
            detail="Erasure not applicable (legal obligation to retain)"
        )

    # Delete from all systems
    deletion_results = {
        "user_profile": await db.users.delete_one({"id": user_id}),
        "conversations": await db.conversations.delete_many({"user_id": user_id}),
        "preferences": await db.preferences.delete_one({"user_id": user_id}),
        "consents": await db.consents.delete_many({"user_id": user_id}),
        "sessions": await db.sessions.delete_many({"user_id": user_id})
    }

    # Notify third-party processors (DPA requirement)
    await notify_processors_of_erasure(user_id)

    # Audit the erasure (keep minimal log)
    await audit_log.info(
        event="data_erased",
        user_id_hash=hash_user_id(user_id),  # Pseudonymized
        reason=reason,
        records_deleted=sum(r.deleted_count for r in deletion_results.values())
    )

    # Invalidate all tokens
    await revoke_all_tokens(user_id)

    return {"status": "data_erased", "user_id": user_id}
```

---

### 4. Right to Data Portability (Article 20)

```python
@router.get("/api/v1/gdpr/data-portability")
async def export_portable_data(
    format: str = "json",  # json, csv, xml
    user_id: str = Depends(get_current_user)
):
    """Export data in machine-readable format (Article 20)."""

    # Collect data provided by the data subject
    portable_data = {
        "user_profile": await db.users.find_one({"id": user_id}),
        "preferences": await db.preferences.find_one({"user_id": user_id}),
        "conversation_history": await db.conversations.find(
            {"user_id": user_id}
        ).to_list(None)
    }

    # Format conversion
    if format == "json":
        export_content = json.dumps(portable_data, indent=2)
        media_type = "application/json"
    elif format == "csv":
        export_content = convert_to_csv(portable_data)
        media_type = "text/csv"
    elif format == "xml":
        export_content = convert_to_xml(portable_data)
        media_type = "application/xml"

    await audit_log.info(
        event="data_portability_export",
        user_id=user_id,
        format=format
    )

    return Response(
        content=export_content,
        media_type=media_type,
        headers={"Content-Disposition": f"attachment; filename=data-export.{format}"}
    )
```

---

### 5. Right to Object (Article 21)

```python
@router.post("/api/v1/gdpr/object-to-processing")
async def object_to_processing(
    purpose: str,
    user_id: str = Depends(get_current_user)
):
    """Allow user to object to processing (Article 21)."""

    # Stop processing for specified purpose
    await db.consents.update_one(
        {"user_id": user_id, "purpose": purpose},
        {
            "$set": {
                "consent_given": False,
                "objection_raised": True,
                "objection_timestamp": datetime.utcnow()
            }
        }
    )

    # Immediately stop ongoing processing
    await stop_processing_for_purpose(user_id, purpose)

    await audit_log.info(
        event="processing_objection",
        user_id=user_id,
        purpose=purpose
    )

    return {"status": "objection_recorded", "purpose": purpose}
```

---

## Data Protection by Design and Default (Article 25)

### Privacy-Preserving Configuration

```yaml
# config/privacy_by_default.yaml
privacy_settings:
  # Default to most privacy-protective settings
  defaults:
    data_collection: "minimal"  # Only essential data
    sharing: "none"  # No third-party sharing by default
    retention: "shortest"  # Shortest retention period
    analytics: "anonymized_only"  # No personal data in analytics
    profiling: "disabled"  # No automated profiling
    marketing: "opt_out"  # No marketing communications

  # User must explicitly opt-in for additional processing
  opt_in_required:
    - "service_improvement_analytics"
    - "personalized_recommendations"
    - "third_party_integrations"
    - "extended_data_retention"

  # Pseudonymization by default
  pseudonymization:
    enabled: true
    fields:
      - "user_id"
      - "session_id"
      - "ip_address"
    method: "HMAC-SHA256"
    key_rotation: "90_days"
```

---

## Data Protection Impact Assessment (DPIA)

**Required for high-risk processing (Article 35):**

### DPIA Template

```markdown
# Data Protection Impact Assessment (DPIA)

## 1. Description of Processing Operation

**Processing Activity**: AI Agent Query Processing
**Purpose**: Provide AI-powered responses to user queries
**Data Controller**: [Your Organization]
**Data Processor**: MCP Server with LangGraph

**Personal Data Processed**:
- User queries (may contain personal information)
- User preferences
- Conversation history
- Usage analytics

## 2. Necessity and Proportionality Assessment

**Is processing necessary?** Yes
**Justification**: Required to provide core service functionality

**Is data collection proportionate?** Yes
**Data Minimization**: Only collect query text and minimal session data

## 3. Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Unauthorized access to queries | Low | High | End-to-end encryption, access controls |
| Data breach | Low | High | Encryption at rest, security monitoring |
| Profiling without consent | Medium | Medium | Explicit opt-in required, transparency |
| Third-party data sharing | Low | High | DPAs required, user consent |

## 4. Measures to Address Risks

**Technical Measures:**
- Encryption in transit (TLS 1.3)
- Encryption at rest (AES-256)
- Pseudonymization of user identifiers
- Access controls (OpenFGA)
- Audit logging (7-year retention)

**Organizational Measures:**
- Privacy training for staff
- Data protection policies
- Breach notification procedures
- Regular security audits

## 5. Consultation with DPO

**DPO Consulted**: [Name], [Date]
**DPO Opinion**: Risks adequately mitigated with proposed measures
**DPO Signature**: __________________

## 6. Approval

**Approved By**: [Data Controller]
**Date**: [Date]
**Review Date**: [Annual review]
```

---

## Data Processing Agreement (DPA) Template

```markdown
# Data Processing Agreement (DPA)

This Data Processing Agreement is entered into between:

**Controller**: [Your Organization] ("Controller")
**Processor**: [Vendor Name] ("Processor")

## 1. Subject Matter and Duration

**Subject Matter**: Provision of [Service Description]
**Duration**: As per Main Agreement
**Nature and Purpose**: Processing personal data to provide AI agent services

## 2. Obligations of the Processor

The Processor shall:

a) Process personal data only on documented instructions from the Controller;

b) Ensure persons authorized to process personal data have committed to confidentiality;

c) Implement appropriate technical and organizational measures (Article 32);

d) Respect conditions for engaging sub-processors (Article 28(2) and (4));

e) Assist the Controller in responding to data subject rights requests;

f) Assist the Controller in ensuring compliance with Articles 32-36 (security, breach notification, DPIA);

g) Delete or return all personal data after end of provision of services;

h) Make available all information necessary to demonstrate compliance.

## 3. Technical and Organizational Measures

**Encryption**:
- TLS 1.3 in transit
- AES-256 at rest

**Access Control**:
- Multi-factor authentication
- Role-based access control
- Least privilege principle

**Monitoring**:
- 24/7 security monitoring
- Audit logging
- Intrusion detection

## 4. Sub-Processors

Approved Sub-Processors:
- Google Cloud Platform (infrastructure) - [DPA Link]
- Anthropic/Google (LLM providers) - [DPA Link]

Controller authorizes engagement of sub-processors listed above.
Processor must notify Controller of any intended changes (addition/replacement) with 30 days notice.

## 5. Data Subject Rights

Processor shall assist Controller in responding to data subject requests:
- Access (Article 15)
- Rectification (Article 16)
- Erasure (Article 17)
- Restriction (Article 18)
- Portability (Article 20)
- Objection (Article 21)

Response time: Within 72 hours of Controller request

## 6. Personal Data Breach Notification

Processor shall notify Controller without undue delay (and within 24 hours) after becoming aware of a personal data breach.

Notification must include:
- Nature of breach
- Categories and approximate number of data subjects affected
- Likely consequences
- Measures taken or proposed

## 7. Audits and Inspections

Processor shall allow Controller (or auditor) to conduct audits annually.
Processor shall provide all information necessary to demonstrate compliance.

---

**Controller**: ________________________   Date: __________

**Processor**: ________________________   Date: __________
```

---

## GDPR Compliance Checklist

<Steps>
  <Step title="Lawful Basis">
    - [ ] Identify lawful basis for each processing activity
    - [ ] Document lawful basis in privacy policy
    - [ ] Implement consent management system
    - [ ] Enable consent withdrawal mechanism
    - [ ] Conduct Legitimate Interests Assessment (if applicable)
  </Step>

  <Step title="Data Subject Rights">
    - [ ] Implement data export API (Article 15)
    - [ ] Implement data rectification API (Article 16)
    - [ ] Implement data erasure API (Article 17)
    - [ ] Implement data portability API (Article 20)
    - [ ] Implement objection mechanism (Article 21)
    - [ ] Test all rights mechanisms
    - [ ] Document response procedures
  </Step>

  <Step title="Data Protection">
    - [ ] Enable encryption in transit (TLS 1.3)
    - [ ] Enable encryption at rest
    - [ ] Implement pseudonymization
    - [ ] Configure data minimization
    - [ ] Set up automated retention/deletion
    - [ ] Deploy within EU region
    - [ ] Implement access controls
  </Step>

  <Step title="Documentation">
    - [ ] Complete Records of Processing Activities (ROPA)
    - [ ] Conduct Data Protection Impact Assessment (DPIA)
    - [ ] Draft privacy policy / privacy notice
    - [ ] Create cookie policy (if applicable)
    - [ ] Document technical measures
    - [ ] Prepare breach notification procedures
  </Step>

  <Step title="Agreements">
    - [ ] Obtain DPAs from all processors
    - [ ] Review and sign processor DPAs
    - [ ] Document sub-processor relationships
    - [ ] Obtain adequate safeguards for transfers outside EU
  </Step>

  <Step title="Organizational">
    - [ ] Appoint Data Protection Officer (if required)
    - [ ] Conduct privacy training for staff
    - [ ] Establish data protection policies
    - [ ] Create incident response plan
    - [ ] Schedule regular compliance audits
  </Step>
</Steps>

---

## Data Residency Configuration

```yaml
# config/data_residency.yaml
data_residency:
  # EU-only data storage for GDPR compliance
  regions:
    primary: "europe-west1"  # Belgium
    failover: "europe-west4"  # Netherlands
    backup: "europe-west3"  # Frankfurt

  # Allowed regions for processing
  allowed_regions:
    - "eu-*"  # All EU regions
    - "europe-*"  # All European regions

  # Blocked regions (non-EEA without adequacy decision)
  blocked_regions:
    - "us-*"  # United States
    - "asia-*"  # Asia (except with adequate safeguards)

  # Data transfer safeguards (for approved transfers)
  transfer_safeguards:
    mechanism: "Standard_Contractual_Clauses_2021"
    scc_module: "Controller_to_Processor"
    supplementary_measures:
      - encryption_in_transit_and_rest
      - pseudonymization
      - access_controls

# Kubernetes deployment with region affinity
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-server-eu
spec:
  template:
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
              - matchExpressions:
                  - key: topology.kubernetes.io/region
                    operator: In
                    values:
                      - europe-west1
                      - europe-west3
                      - europe-west4
```

---

## Breach Notification (Article 33-34)

### 72-Hour Notification Requirement

```python
# src/incidents/gdpr_breach.py
from datetime import datetime, timedelta

class GDPRBreachNotification:
    """Manage GDPR breach notification requirements."""

    NOTIFICATION_DEADLINE = timedelta(hours=72)

    async def detect_breach(self, incident: dict):
        """Detect and classify potential data breach."""
        # Classify breach severity
        severity = self.classify_breach(incident)

        if severity in ["high", "medium"]:
            # Start breach notification clock
            breach_record = {
                "incident_id": incident["id"],
                "detected_at": datetime.utcnow(),
                "notification_deadline": datetime.utcnow() + self.NOTIFICATION_DEADLINE,
                "severity": severity,
                "status": "under_investigation",
                "affected_individuals": []
            }

            await self.db.breaches.insert_one(breach_record)
            await self.alert_dpo(breach_record)

            return breach_record

    async def assess_breach_risk(self, breach_id: str):
        """Assess risk to individuals' rights and freedoms."""
        breach = await self.db.breaches.find_one({"_id": breach_id})

        # Determine if notification required
        risk_assessment = {
            "identity_theft_risk": "low",  # Assess actual risk
            "financial_loss_risk": "low",
            "discrimination_risk": "low",
            "reputation_damage_risk": "medium",
            "overall_risk": "medium"
        }

        # Update breach record
        await self.db.breaches.update_one(
            {"_id": breach_id},
            {"$set": {"risk_assessment": risk_assessment}}
        )

        # If high risk, notify individuals (Article 34)
        if risk_assessment["overall_risk"] == "high":
            await self.notify_individuals(breach_id)

        return risk_assessment

    async def notify_supervisory_authority(self, breach_id: str):
        """Notify supervisory authority within 72 hours (Article 33)."""
        breach = await self.db.breaches.find_one({"_id": breach_id})

        notification = {
            "breach_id": breach_id,
            "notification_date": datetime.utcnow(),
            "description": breach["description"],
            "categories_of_data": breach["data_categories"],
            "approximate_number_affected": len(breach["affected_individuals"]),
            "likely_consequences": breach["risk_assessment"]["overall_risk"],
            "measures_taken": breach["mitigation_actions"],
            "dpo_contact": {
                "name": "Data Protection Officer",
                "email": "dpo@example.com",
                "phone": "+XX XXX XXX XXXX"
            }
        }

        # Send to supervisory authority
        # (Implementation depends on jurisdiction)
        await self.send_to_authority(notification)

        await self.db.breaches.update_one(
            {"_id": breach_id},
            {"$set": {"authority_notified_at": datetime.utcnow()}}
        )
```

---

## Next Steps

<CardGroup cols={2}>
  <Card title="GDPR API Reference" icon="code" href="/api-reference/gdpr-endpoints">
    REST API documentation for GDPR endpoints
  </Card>
  <Card title="HIPAA Compliance" icon="shield-check" href="/compliance/hipaa-compliance">
    US healthcare data protection
  </Card>
  <Card title="SOC 2 Compliance" icon="file-shield" href="/compliance/soc2-compliance">
    Security controls for service organizations
  </Card>
  <Card title="Deploy in EU" icon="globe" href="/deployment/kubernetes">
    EU-region deployment guide
  </Card>
  <Card title="Security Best Practices" icon="lock" href="/security/best-practices">
    Additional security hardening
  </Card>
</CardGroup>

---

<Warning>
**Final Reminder**: This guide provides technical implementation guidance for GDPR compliance. Full compliance requires:
- Appointment of DPO (if required under Article 37)
- Privacy policies and notices
- Workforce training
- Regular compliance audits
- DPAs with all processors
- Adequate safeguards for international transfers

Consult with legal counsel and your DPO before processing personal data in the EU.
</Warning>
