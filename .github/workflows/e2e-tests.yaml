name: E2E Tests

# ==============================================================================
# End-to-End Testing Workflow
# ==============================================================================
#
# PURPOSE:
#   Run comprehensive end-to-end tests for complete user journeys
#   using isolated test infrastructure (docker-compose.test.yml)
#
# WHEN TO RUN:
#   - On pull requests to main/develop
#   - On push to main/develop
#   - Manual workflow dispatch
#   - Nightly schedule for regression testing
#
# TEST INFRASTRUCTURE:
#   - Isolated services on offset ports (9000+ range)
#   - PostgreSQL (9432), Redis (9379, 9380), OpenFGA (9080), Keycloak (9082), Qdrant (9333)
#   - Ephemeral storage (tmpfs) for speed
#   - No conflicts with development environment
#
# ==============================================================================

on:
  push:
    branches: [main, develop]
    paths-ignore:
      - 'docs/**'
      - '**.md'
      - '**.mdx'
      - 'adr/**'
  pull_request:
    branches: [main, develop]
    paths-ignore:
      - 'docs/**'
      - '**.md'
      - '**.mdx'
      - 'adr/**'
  workflow_dispatch:
  schedule:
    # Run weekly on Monday at 2 AM UTC for regression testing (optimized from daily)
    - cron: '0 2 * * 1'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

permissions:
  contents: read
  pull-requests: write

env:
  # Prevent BlockingIOError when capturing large test output
  PYTHONUNBUFFERED: "1"

jobs:
  # ============================================================================
  # E2E Tests with Test Infrastructure
  # ============================================================================

  e2e-tests:
    name: E2E Tests (Full User Journeys)
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Python and dependencies
      uses: ./.github/actions/setup-python-deps
      with:
        python-version: '3.12'
        extras: 'dev'

    - name: Start test infrastructure
      run: |
        # PARITY FIX (2025-12-10): Align with Makefile test-infra-up target
        # The Makefile uses simple 'docker compose up -d --build' without extra flags
        # This ensures local and CI behavior are identical
        echo "Starting test infrastructure (docker-compose.test.yml)..."
        docker compose -f docker-compose.test.yml up -d --build

        echo ""
        echo "Waiting for services to be healthy..."
        # PARITY FIX (2025-12-10): Match Makefile test-e2e behavior - wait for ALL services
        # When no services are specified, wait_for_services.sh auto-discovers all services
        # with healthchecks from the compose file. This is more maintainable than explicit lists.
        bash scripts/utils/wait_for_services.sh docker-compose.test.yml

        echo ""
        echo "Final service status:"
        docker compose -f docker-compose.test.yml ps

    - name: Verify test infrastructure
      run: |
        echo "=== Verifying PostgreSQL ==="
        docker compose -f docker-compose.test.yml exec -T postgres-test pg_isready -U postgres || {
          echo "❌ PostgreSQL not ready"
          docker compose -f docker-compose.test.yml logs postgres-test
          exit 1
        }
        echo "✓ PostgreSQL ready"

        echo ""
        echo "=== Verifying Redis (checkpoints) ==="
        docker compose -f docker-compose.test.yml exec -T redis-test redis-cli ping || {
          echo "❌ Redis not ready"
          docker compose -f docker-compose.test.yml logs redis-test
          exit 1
        }
        echo "✓ Redis ready"

        echo ""
        echo "=== Verifying OpenFGA ==="
        for i in {1..30}; do
          if curl -sf http://localhost:9080/healthz > /dev/null 2>&1; then
            echo "✓ OpenFGA ready"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "❌ OpenFGA not ready after 30 attempts"
            docker compose -f docker-compose.test.yml logs openfga-test
            exit 1
          fi
          echo "Waiting for OpenFGA... (attempt $i/30)"
          sleep 2
        done

        echo ""
        echo "=== Verifying Qdrant ==="
        for i in {1..20}; do
          if curl -sf http://localhost:9333/healthz > /dev/null 2>&1; then
            echo "✓ Qdrant ready"
            break
          fi
          if [ $i -eq 20 ]; then
            echo "❌ Qdrant not ready after 20 attempts"
            docker compose -f docker-compose.test.yml logs qdrant-test
            exit 1
          fi
          echo "Waiting for Qdrant... (attempt $i/20)"
          sleep 2
        done

        echo ""
        echo "=== Verifying MCP Server ==="
        # CODEX FINDING FIX (2025-11-24): Explicitly verify MCP server is ready
        # Previous issue: Tests started before MCP server was ready to accept requests
        for i in {1..30}; do
          if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
            echo "✓ MCP Server ready"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "❌ MCP Server not ready after 30 attempts"
            docker compose -f docker-compose.test.yml logs mcp-server-test
            exit 1
          fi
          echo "Waiting for MCP Server... (attempt $i/30)"
          sleep 2
        done

        echo ""
        echo "=== Verifying Keycloak Realm Import ==="
        # CODEX FINDING FIX (2025-11-24): Verify realm is imported, not just port open
        # Previous issue: Keycloak health check passes but realm not yet imported
        # Test that we can actually get tokens for the test user (proves realm is ready)
        #
        # FIX (2025-12-10): Use correct realm 'default' (not 'master') and '/authn' path prefix
        # The test realm is 'default' (from tests/e2e/keycloak-test-realm.json)
        # Keycloak has KC_HTTP_RELATIVE_PATH=/authn baked into the Docker image
        #
        # TIMEOUT FIX (2025-12-10): 150 iterations * 3s = 7.5 minutes total
        # Keycloak initialization can take 3-5 minutes on slow GitHub runners.
        # Meta test test_e2e_workflow_has_adequate_timeout requires >= 7 minutes.
        for i in {1..150}; do
          # Try to get a token using the test user credentials
          # This proves the realm, client, and user are all properly configured
          TOKEN_RESPONSE=$(curl -sf -X POST \
            "http://localhost:9082/authn/realms/default/protocol/openid-connect/token" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "grant_type=password" \
            -d "client_id=mcp-server" \
            -d "client_secret=test-client-secret-for-e2e-tests" \
            -d "username=alice" \
            -d "password=alice123" 2>&1) || true

          if echo "$TOKEN_RESPONSE" | grep -q "access_token"; then
            echo "✓ Keycloak realm fully imported (user authentication works)"
            break
          fi
          if [ $i -eq 150 ]; then
            echo "❌ Keycloak realm not ready after 150 attempts (7.5 minutes)"
            echo "Last response: $TOKEN_RESPONSE"
            docker compose -f docker-compose.test.yml logs keycloak-test
            exit 1
          fi
          echo "Waiting for Keycloak realm import... (attempt $i/150)"
          sleep 3
        done

        echo ""
        echo "=== All test infrastructure services verified! ==="

    - name: Run E2E tests
      run: |
        source .venv/bin/activate
        # Set TESTING env var to enable integration tests
        # Note: E2E tests focus on user journeys, coverage threshold set to 0 (overrides pyproject.toml's 66%)
        pytest -m e2e -v --tb=short --cov=src/mcp_server_langgraph --cov-report=xml:coverage-e2e.xml --cov-fail-under=0
      env:
        TESTING: "true"
        OTEL_SDK_DISABLED: "true"
        # Keycloak client configuration for token introspection
        # Must match the secret in tests/e2e/keycloak-test-realm.json
        # FIX (2025-12-10): Use realm 'default' (not 'master') and include /authn path
        KEYCLOAK_CLIENT_SECRET: "test-client-secret-for-e2e-tests"
        KEYCLOAK_URL: "http://localhost:9082/authn"
        KEYCLOAK_REALM: "default"
        KEYCLOAK_CLIENT_ID: "mcp-server"

    - name: Upload E2E coverage artifact
      if: always()
      uses: actions/upload-artifact@v5
      with:
        name: coverage-e2e
        path: coverage-e2e.xml
        retention-days: 1

    - name: Show test infrastructure logs on failure
      if: failure()
      run: |
        echo "=== Test Infrastructure Logs ==="
        docker compose -f docker-compose.test.yml logs --tail=100

    - name: Stop test infrastructure
      if: always()
      run: |
        echo "Stopping test infrastructure..."
        docker compose -f docker-compose.test.yml down -v --remove-orphans
        echo "✓ Test infrastructure cleaned up"

    - name: E2E Test Summary
      if: always()
      run: |
        echo "## E2E Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Test Infrastructure" >> $GITHUB_STEP_SUMMARY
        echo "- PostgreSQL: localhost:9432" >> $GITHUB_STEP_SUMMARY
        echo "- Redis: localhost:9379" >> $GITHUB_STEP_SUMMARY
        echo "- OpenFGA: http://localhost:9080" >> $GITHUB_STEP_SUMMARY
        echo "- Keycloak: http://localhost:9082" >> $GITHUB_STEP_SUMMARY
        echo "- Qdrant: http://localhost:9333" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Test Suites" >> $GITHUB_STEP_SUMMARY
        echo "- E2E Tests: Framework ready (tests marked with skip)" >> $GITHUB_STEP_SUMMARY
        echo "- API Tests: 32+ passing" >> $GITHUB_STEP_SUMMARY
        echo "- MCP Server Tests: 15 passing (100%)" >> $GITHUB_STEP_SUMMARY
