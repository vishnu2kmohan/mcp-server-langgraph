"""
Meta-validation: Ensure Git hooks match CI/CD configuration exactly.

This test suite ensures that:
1. Pre-push hook uses `-n auto` for all pytest calls (matches CI)
2. Pre-push hook has MyPy configured as blocking (matches CI)
3. Post-commit hook uses project-managed Python runtime (uv run)
4. Hook configurations stay in sync with CI/CD workflows

TDD Principle: These tests prevent configuration drift between local hooks and CI.
They MUST pass to ensure consistent validation behavior everywhere.

Related:
- tests/meta/test_local_ci_parity.py - Overall CI/local parity
- tests/meta/test_pytest_xdist_enforcement.py - xdist enforcement
- .git/hooks/pre-push - Pre-push hook implementation
- .github/workflows/ci.yaml - CI workflow configuration
"""

import gc
import os
import re
import subprocess
from pathlib import Path
from typing import List

import pytest

# Mark as unit+meta test to ensure it runs in CI (validates test infrastructure)
pytestmark = [pytest.mark.unit, pytest.mark.meta]


@pytest.mark.skipif(os.getenv("CI") == "true", reason="Pre-push hooks not installed in CI environment")
@pytest.mark.xdist_group(name="testprepushhooksync")
class TestPrePushHookSync:
    """Validate pre-push hook configuration matches CI expectations."""

    def teardown_method(self) -> None:
        """Force GC to prevent mock accumulation in xdist workers"""
        gc.collect()

    @pytest.fixture
    def repo_root(self) -> Path:
        """Get repository root directory."""
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True, check=True, timeout=60
        )
        return Path(result.stdout.strip())

    @pytest.fixture
    def pre_push_script_path(self, repo_root: Path) -> Path:
        """
        Get path to pre-push test orchestrator script.

        NOTE: .git/hooks/pre-push is auto-generated by pre-commit framework and
        doesn't contain validation logic. The actual validation is in:
        - scripts/run_pre_push_tests.py (test orchestrator)
        - Makefile validate-pre-push (comprehensive CI-equivalent validation)
        """
        return repo_root / "scripts" / "run_pre_push_tests.py"

    @pytest.fixture
    def pre_push_hook_content(self, pre_push_script_path: Path) -> str:
        """
        Read pre-push test orchestrator script content.

        This is the actual validation logic, not the auto-generated hook wrapper.
        """
        assert (
            pre_push_script_path.exists()
        ), "Pre-push test orchestrator script does not exist at scripts/run_pre_push_tests.py"
        return pre_push_script_path.read_text()

    def test_all_pytest_calls_use_n_auto(self, pre_push_hook_content: str):
        """
        Test that pre-push test orchestrator configures pytest with -n auto.

        Rationale:
        - CI uses `-n auto` to adapt to available GitHub runner cores
        - Local pre-push should match for consistent behavior
        - Using fixed worker counts (e.g., -n 4) causes:
          * Different parallel execution patterns locally vs CI
          * Missed pytest-xdist isolation bugs
          * Inconsistent test timing and resource usage

        Expected: scripts/run_pre_push_tests.py must configure -n auto
        """
        # Check if the script configures -n auto in pytest_args
        # The script uses: pytest_args.extend(["-n", "auto"])
        has_n_auto = '"-n"' in pre_push_hook_content and '"auto"' in pre_push_hook_content

        # Alternative pattern: might be written as pytest_args.append("-n auto")
        has_n_auto_alt = '"-n auto"' in pre_push_hook_content or "-n auto" in pre_push_hook_content

        assert has_n_auto or has_n_auto_alt, (
            "Pre-push test orchestrator must configure pytest with '-n auto' for parallel execution\n"
            "\n"
            "Expected pattern in scripts/run_pre_push_tests.py:\n"
            '  pytest_args.extend(["-n", "auto"])  # Parallel execution\n'
            "\n"
            "Why this matters:\n"
            "- CI uses '-n auto' to adapt to runner cores\n"
            "- Fixed worker counts (e.g., -n 4) cause:\n"
            "  * Different parallel execution patterns locally vs CI\n"
            "  * Missed pytest-xdist isolation bugs\n"
            "  * Inconsistent test timing and resource usage\n"
            "\n"
            "Fix: Ensure scripts/run_pre_push_tests.py includes:\n"
            '  pytest_args = ["pytest", "-n", "auto", ...]\n'
        )

    def test_mypy_is_blocking(self, repo_root: Path):
        """
        Test that MyPy type checking is configured as blocking (critical).

        NOTE: MyPy is NOT in the pre-commit test orchestrator (scripts/run_pre_push_tests.py).
        It's only in Makefile validate-pre-push target, which provides comprehensive
        CI-equivalent validation beyond just running tests.

        Rationale:
        - CI blocks on MyPy errors (no continue-on-error flag)
        - Local validation must match to prevent CI surprises
        - Warning-only MyPy locally means:
          * Developers push code with type errors
          * CI fails unexpectedly
          * Requires force-push fixes
          * Wastes time and breaks flow

        Expected: Makefile validate-pre-push must have blocking MyPy
        """
        # Read Makefile to check MyPy configuration
        makefile_path = repo_root / "Makefile"
        makefile_content = makefile_path.read_text()

        # Extract validate-pre-push target
        target_pattern = r"^validate-pre-push:.*?(?=^\S|\Z)"
        target_match = re.search(target_pattern, makefile_content, re.MULTILINE | re.DOTALL)

        assert target_match, "Could not find validate-pre-push target in Makefile"
        target_content = target_match.group(0)

        # Find MyPy command
        mypy_pattern = r"mypy src/mcp_server_langgraph.*"
        mypy_match = re.search(mypy_pattern, target_content)

        assert mypy_match, "MyPy not found in Makefile validate-pre-push target"

        # Get context to check for blocking pattern
        mypy_start = mypy_match.start()
        mypy_end = min(mypy_start + 150, len(target_content))
        mypy_context = target_content[mypy_start:mypy_end]

        # Should have "exit 1" (blocking) not just "|| echo warning" (non-blocking)
        has_exit_1 = "exit 1" in mypy_context
        has_warning_only = "|| echo" in mypy_context and "exit 1" not in mypy_context

        assert has_exit_1 and not has_warning_only, (
            "MyPy must be blocking (use && echo success || (echo error && exit 1))\n"
            "\n"
            "Why this matters:\n"
            "- CI blocks on MyPy errors (fails build if types are wrong)\n"
            "- Local validation warning-only means:\n"
            "  * Developers push code that fails CI\n"
            "  * Surprise failures in GitHub Actions\n"
            "  * Wasted time and context switching\n"
            "\n"
            f"Found context:\n{mypy_context}\n"
            "\n"
            "Fix: Ensure Makefile validate-pre-push uses:\n"
            "  @$(UV_RUN) mypy ... && echo success || (echo error && exit 1)\n"
        )

    def test_no_hardcoded_worker_counts(self, pre_push_hook_content: str):
        """
        Test that pre-push hook does not use hardcoded worker counts like -n 4.

        This is a negative test to catch regressions where someone might
        add a new pytest call with a fixed worker count.
        """
        # Find all pytest invocations with -n followed by a number
        hardcoded_pattern = r'pytest\s+[^"\n]*-n\s+\d+'
        matches = list(re.finditer(hardcoded_pattern, pre_push_hook_content))

        if matches:
            failing_lines = "\n".join([m.group(0) for m in matches])
            pytest.fail(
                f"Pre-push hook contains hardcoded worker counts (e.g., -n 4)\n"
                f"Found:\n{failing_lines}\n"
                f"\n"
                f"Fix: Replace all hardcoded counts with '-n auto' to match CI"
            )


@pytest.mark.xdist_group(name="testpostcommithooksync")
class TestPostCommitHookSync:
    """Validate post-commit hook uses project-managed Python runtime."""

    def teardown_method(self) -> None:
        """Force GC to prevent mock accumulation in xdist workers"""
        gc.collect()

    @pytest.fixture
    def repo_root(self) -> Path:
        """Get repository root directory."""
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True, check=True, timeout=60
        )
        return Path(result.stdout.strip())

    @pytest.fixture
    def post_commit_hook_path(self, repo_root: Path) -> Path:
        """Get path to post-commit hook."""
        return repo_root / ".git" / "hooks" / "post-commit"

    @pytest.fixture
    def post_commit_hook_content(self, post_commit_hook_path: Path) -> str:
        """Read post-commit hook content."""
        if not post_commit_hook_path.exists():
            pytest.skip("Post-commit hook does not exist (optional)")
        return post_commit_hook_path.read_text()

    def test_uses_uv_run_python(self, post_commit_hook_content: str):
        """
        Test that post-commit hook uses 'uv run python' instead of bare 'python'.

        Rationale:
        - Project uses uv for dependency management
        - Bare 'python' uses global interpreter (may have wrong deps)
        - 'uv run python' ensures project-managed runtime
        - Consistency across all automation

        Expected: All python invocations use 'uv run python'
        """
        # Find all python invocations
        python_lines = [
            line for line in post_commit_hook_content.split("\n") if "python" in line and not line.strip().startswith("#")
        ]

        for line in python_lines:
            # Skip shebang lines
            if line.strip().startswith("#!"):
                continue

            # Check for bare python usage (not preceded by 'uv run')
            if re.search(r"\bpython\b", line) and "uv run python" not in line:
                assert False, (
                    f"Post-commit hook must use 'uv run python' for consistency\n"
                    f"Found: {line.strip()}\n"
                    f"\n"
                    f"Why this matters:\n"
                    f"- Bare 'python' uses global interpreter\n"
                    f"- May have wrong dependencies or Python version\n"
                    f"- 'uv run python' ensures project-managed runtime\n"
                    f"- Consistency with other automation\n"
                    f"\n"
                    f"Fix: Replace 'python' with 'uv run python' in .git/hooks/post-commit"
                )


@pytest.mark.xdist_group(name="testhooktemplatesync")
class TestHookTemplateSync:
    """Validate hook templates stay in sync or are properly removed."""

    def teardown_method(self) -> None:
        """Force GC to prevent mock accumulation in xdist workers"""
        gc.collect()

    @pytest.fixture
    def repo_root(self) -> Path:
        """Get repository root directory."""
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"], capture_output=True, text=True, check=True, timeout=60
        )
        return Path(result.stdout.strip())

    @pytest.fixture
    def template_hook_path(self, repo_root: Path) -> Path:
        """Get path to template pre-push hook."""
        return repo_root / "scripts" / "git-hooks" / "pre-push"

    def test_template_matches_or_documented(self, repo_root: Path, template_hook_path: Path):
        """
        Test that template hook is either in sync with actual hook or documented as obsolete.

        Rationale:
        - scripts/git-hooks/pre-push is a tracked template
        - If it differs from .git/hooks/pre-push, it's confusing
        - Either keep them in sync or remove the template
        - Add documentation explaining the state

        This test will pass if:
        1. Template doesn't exist (removed as obsolete), OR
        2. Template contains a deprecation notice, OR
        3. Template matches actual hook configuration
        """
        if not template_hook_path.exists():
            # Template removed - that's fine
            return

        template_content = template_hook_path.read_text()

        # Check if template has deprecation notice
        deprecation_keywords = ["obsolete", "deprecated", "legacy", "do not use"]
        has_deprecation = any(keyword in template_content.lower() for keyword in deprecation_keywords)

        if has_deprecation:
            # Template is documented as obsolete - that's fine
            return

        # If template exists and is not marked obsolete, it should match actual hook
        actual_hook_path = repo_root / ".git" / "hooks" / "pre-push"
        if actual_hook_path.exists():
            actual_content = actual_hook_path.read_text()

            # Check for key configuration markers
            template_uses_n_auto = "-n auto" in template_content
            actual_uses_n_auto = "-n auto" in actual_content

            assert template_uses_n_auto == actual_uses_n_auto, (
                f"Template hook and actual hook have different pytest worker configurations\n"
                f"Template (-n auto): {template_uses_n_auto}\n"
                f"Actual (-n auto): {actual_uses_n_auto}\n"
                f"\n"
                f"Fix options:\n"
                f"1. Sync template to match actual hook\n"
                f"2. Remove template if obsolete\n"
                f"3. Add deprecation notice to template\n"
            )
