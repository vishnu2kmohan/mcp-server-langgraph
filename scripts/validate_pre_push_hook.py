#!/usr/bin/env python3
"""
Validate that .git/hooks/pre-push is configured correctly.

This script ensures that the pre-push hook:
1. Exists and is executable
2. Contains all required validation steps (either directly or via pre-commit framework)
3. Matches expected configuration with 4 phases:
   - Phase 1: Fast checks (lockfile, dependency validation, workflows)
   - Phase 2: Type checking (MyPy - CRITICAL, blocks on errors)
   - Phase 3: Test suite validation (unit, smoke, integration, API, MCP, property, xdist meta)
   - Phase 4: Pre-commit hooks (push stage - comprehensive validators)

Supported Patterns:
   - Pre-commit framework wrapper (validates .pre-commit-config.yaml)
   - Custom bash script with 4-phase structure (legacy)

This prevents regressions where the pre-push hook might be accidentally
modified or removed, causing local validation to diverge from requirements.

Updated 2025-11-15: Added support for pre-commit framework wrapper pattern.
Updated 2025-11-13: Added comprehensive test suite validation to match CI exactly.
"""

import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple

import yaml


def get_repo_root() -> Path:
    """Get repository root directory."""
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True,
    )
    return Path(result.stdout.strip())


def is_pre_commit_wrapper(content: str) -> bool:
    """
    Detect if hook is a pre-commit framework wrapper.

    Args:
        content: Hook file content

    Returns:
        True if hook is generated by pre-commit framework
    """
    wrapper_patterns = [
        r"File generated by pre-commit:",
        r"pre_commit",
        r"--hook-type=pre-push",
        r"exec.*python.*-mpre_commit",
    ]
    return any(re.search(pattern, content) for pattern in wrapper_patterns)


def validate_pre_commit_config(repo_root: Path) -> Tuple[bool, List[str]]:
    """
    Validate .pre-commit-config.yaml has all required pre-push hooks.

    Args:
        repo_root: Repository root path

    Returns:
        Tuple of (is_valid, error_messages)
    """
    errors = []
    config_path = repo_root / ".pre-commit-config.yaml"

    if not config_path.exists():
        errors.append(
            "‚ùå .pre-commit-config.yaml not found\n" "   Fix: Restore .pre-commit-config.yaml or run 'pre-commit install'"
        )
        return False, errors

    # Load config
    try:
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
    except yaml.YAMLError as e:
        errors.append(f"‚ùå Failed to parse .pre-commit-config.yaml: {e}")
        return False, errors

    # Extract all hooks with stages: [pre-push]
    pre_push_hooks = []
    for repo in config.get("repos", []):
        for hook in repo.get("hooks", []):
            stages = hook.get("stages", ["commit"])  # Default stage is commit
            if "pre-push" in stages or stages == ["pre-push"]:
                pre_push_hooks.append(
                    {
                        "id": hook["id"],
                        "entry": hook.get("entry", ""),
                    }
                )

    if not pre_push_hooks:
        errors.append(
            "‚ùå No hooks configured with 'stages: [pre-push]' in .pre-commit-config.yaml\n"
            "   Fix: Add pre-push hooks to .pre-commit-config.yaml"
        )
        return False, errors

    # Check for minimum required validations
    # Updated 2025-11-16: Relaxed validation to support different hook organizations
    # Hooks may be organized by domain (deployment, documentation, etc.) rather than test type
    required_patterns = {
        "mypy": r"mypy|type.*check",
        "pytest": r"pytest|test",  # Any pytest usage is OK
        "deployment_validation": r"(test_(helm|kustomize|network|service)|deployment)",
        "documentation": r"(test_documentation|mintlify|docs)",
    }

    found_required = {category: False for category in required_patterns}
    warnings = []

    for hook in pre_push_hooks:
        hook_text = f"{hook['id']} {hook['entry']}".lower()
        for category, pattern in required_patterns.items():
            if re.search(pattern, hook_text):
                found_required[category] = True

    missing_required = [cat for cat, found in found_required.items() if not found]

    if missing_required:
        errors.append(
            "‚ùå Required validations missing from .pre-commit-config.yaml:\n"
            + "\n".join(f"   - {cat}" for cat in missing_required)
            + "\n   Fix: Ensure these validations are configured in pre-push hooks"
        )

    # Optional validation categories (warnings only, don't fail)
    optional_patterns = {
        "unit_tests": r"pytest.*(unit|tests/unit)",
        "smoke_tests": r"pytest.*(smoke|tests/smoke)",
        "integration_tests": r"pytest.*(integration|tests/integration)",
    }

    for category, pattern in optional_patterns.items():
        found = any(re.search(pattern, f"{hook['id']} {hook['entry']}".lower()) for hook in pre_push_hooks)
        if not found:
            warnings.append(
                f"‚ÑπÔ∏è  Optional validation not found: {category}\n"
                f"   Hooks may be organized differently (domain-specific vs test-type)"
            )

    # Count total pre-push hooks (informational)
    hook_count = len(pre_push_hooks)
    if hook_count < 10:
        warnings.append(f"‚ÑπÔ∏è  Only {hook_count} pre-push hooks found\n" "   Note: Expected 40+ for comprehensive validation")

    # Print warnings if any (non-blocking)
    if warnings:
        print("\n‚ÑπÔ∏è  Informational Notes:")
        for warning in warnings:
            print(f"   {warning}")

    return len(errors) == 0, errors


def check_pre_push_hook() -> Tuple[bool, List[str]]:
    """
    Validate pre-push hook configuration.

    Returns:
        Tuple of (is_valid, error_messages)
    """
    errors = []
    repo_root = get_repo_root()
    pre_push_path = repo_root / ".git" / "hooks" / "pre-push"

    # Check 1: File exists
    if not pre_push_path.exists():
        errors.append(
            "‚ùå Pre-push hook does not exist at .git/hooks/pre-push\n"
            "   Fix: Run 'make git-hooks' or 'pre-commit install --hook-type pre-push'"
        )
        return False, errors

    # Check 2: Is executable
    if not os.access(pre_push_path, os.X_OK):
        errors.append(f"‚ùå Pre-push hook exists but is not executable\n" f"   Fix: chmod +x .git/hooks/pre-push")

    # Read hook content
    with open(pre_push_path, "r") as f:
        content = f.read()

    # Check 3: Detect hook type and validate accordingly
    if is_pre_commit_wrapper(content):
        # Pre-commit framework wrapper - validate .pre-commit-config.yaml
        print("‚ÑπÔ∏è  Detected pre-commit framework wrapper")
        print("   Validating .pre-commit-config.yaml for required hooks...")
        return validate_pre_commit_config(repo_root)

    # Legacy custom script - validate 4-phase structure
    print("‚ÑπÔ∏è  Detected custom pre-push script")
    print("   Validating 4-phase structure...")

    # Check 4: Required validation steps (using regex patterns to handle "uv run" wrappers)
    required_validations = {
        # Phase 1: Fast checks
        r"uv lock --check": "Lockfile validation",
        r"test_workflow_syntax\.py": "Workflow syntax validation",
        r"test_workflow_security\.py": "Workflow security validation",
        r"test_workflow_dependencies\.py": "Workflow dependencies validation",
        r"test_docker_paths\.py": "Docker paths validation",
        # Phase 2: Type checking
        r"(uv run )?mypy src/mcp_server_langgraph": "MyPy type checking",
        # Phase 3: Test suite validation (handles "uv run pytest" or just "pytest")
        r"(uv run )?pytest.*tests/.*-m.*unit": "Unit tests",
        r"(uv run )?pytest.*tests/smoke/": "Smoke tests",
        r"(uv run )?pytest.*tests/integration/": "Integration tests",
        r"(uv run )?pytest.*-m.*['\"]api and unit": "API endpoint tests",
        r"(uv run )?pytest.*test_mcp_stdio_server\.py": "MCP server tests",
        r"HYPOTHESIS_PROFILE=ci": "Property tests with CI profile",
        r"(uv run )?pytest.*-m.*property": "Property tests",
        r"(uv run )?pytest.*test_pytest_xdist_enforcement\.py": "pytest-xdist enforcement meta-tests",
        # Phase 4: Pre-commit hooks (push stage)
        r"pre-commit run --all-files.*--hook-stage push": "Pre-commit hooks (push stage)",
    }

    missing_validations = []
    for validation_pattern, description in required_validations.items():
        if not re.search(validation_pattern, content):
            missing_validations.append(f"   - {description} (pattern: {validation_pattern})")

    if missing_validations:
        errors.append(
            "‚ùå Pre-push hook is missing required validation steps:\n"
            + "\n".join(missing_validations)
            + "\n   Fix: Restore .git/hooks/pre-push from template or run 'make git-hooks'"
        )

    # Check 4: Parallel execution with pytest-xdist (-n auto)
    # All test commands should use -n auto to match CI and catch isolation bugs
    pytest_commands = [
        ("Unit tests", "pytest tests/ -m", "-n auto"),
        ("Smoke tests", "pytest tests/smoke/", "-n auto"),
        ("Integration tests", "pytest tests/integration/", "-n auto"),
        ("API tests", "pytest -n auto -m 'api", "-n auto"),
        ("MCP tests", "test_mcp_stdio_server.py", "-n auto"),
        ("Property tests", "pytest -m property", "-n auto"),
        ("pytest-xdist enforcement (Meta)", "test_pytest_xdist_enforcement.py", "-n auto"),
    ]

    missing_n_auto = []
    for test_name, test_cmd, flag in pytest_commands:
        # Find lines containing the test command
        lines = [line for line in content.split("\n") if test_cmd in line]
        if lines:
            # Check if any of those lines have -n auto
            if not any(flag in line for line in lines):
                missing_n_auto.append(f"   - {test_name} (missing '-n auto')")

    if missing_n_auto:
        errors.append(
            "‚ùå Pre-push hook must use '-n auto' for parallel execution to match CI:\n"
            + "\n".join(missing_n_auto)
            + "\n   Fix: Add '-n auto' to all pytest commands in .git/hooks/pre-push"
        )

    # Check 5: OTEL_SDK_DISABLED=true environment variable
    # All test commands should set this to match CI environment
    otel_commands = [
        ("Unit tests", "pytest tests/ -m", "OTEL_SDK_DISABLED=true"),
        ("Smoke tests", "pytest tests/smoke/", "OTEL_SDK_DISABLED=true"),
        ("Integration tests", "pytest tests/integration/", "OTEL_SDK_DISABLED=true"),
        ("API tests", "pytest -n auto -m 'api", "OTEL_SDK_DISABLED=true"),
        ("MCP tests", "test_mcp_stdio_server.py", "OTEL_SDK_DISABLED=true"),
        ("Property tests", "pytest -m property", "OTEL_SDK_DISABLED=true"),
        ("pytest-xdist enforcement (Meta)", "test_pytest_xdist_enforcement.py", "OTEL_SDK_DISABLED=true"),
    ]

    missing_otel = []
    for test_name, test_cmd, env_var in otel_commands:
        # Find lines containing the test command
        lines = [line for line in content.split("\n") if test_cmd in line]
        if lines:
            # Check if any of those lines have OTEL_SDK_DISABLED=true
            if not any(env_var in line for line in lines):
                missing_otel.append(f"   - {test_name} (missing 'OTEL_SDK_DISABLED=true')")

    if missing_otel:
        errors.append(
            "‚ùå Pre-push hook must set 'OTEL_SDK_DISABLED=true' to match CI environment:\n"
            + "\n".join(missing_otel)
            + "\n   Fix: Add 'OTEL_SDK_DISABLED=true' to all pytest commands in .git/hooks/pre-push"
        )

    # Check 4: Has proper structure (phases)
    required_phases = ["PHASE 1", "PHASE 2", "PHASE 3", "PHASE 4"]
    missing_phases = [phase for phase in required_phases if phase not in content]

    if missing_phases:
        errors.append(
            "‚ö†Ô∏è  Pre-push hook is missing clear phase markers:\n"
            + "\n".join(f"   - {phase}" for phase in missing_phases)
            + "\n   This may indicate the hook has been modified"
        )

    # Check 5: Has helpful error messages
    if "--no-verify" not in content:
        errors.append("‚ö†Ô∏è  Pre-push hook should document emergency bypass (--no-verify)")

    return len(errors) == 0, errors


def main() -> int:
    """Main validation function."""
    try:
        is_valid, errors = check_pre_push_hook()

        if is_valid:
            print("‚úÖ Pre-push hook configuration is valid")
            return 0
        else:
            print("Pre-push Hook Validation Failed")
            print("=" * 60)
            for error in errors:
                print(error)
                print()

            print("=" * 60)
            print("\nüí° Quick Fix:")
            print("   make git-hooks")
            print("\nOr manually:")
            print("   pre-commit install --hook-type pre-commit --hook-type pre-push")
            print()

            return 1

    except Exception as e:
        print(f"‚ùå Error validating pre-push hook: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
