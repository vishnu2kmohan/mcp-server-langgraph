#!/usr/bin/env python3
"""
Validate that pre-push hook is installed via pre-commit framework.

This script ensures that:
1. The pre-push hook exists and is executable
2. The hook is managed by pre-commit framework (not a custom script)

KISS Principle (2025-11-30):
- Previous version (418 lines) over-validated hook structure with regex patterns
- Now trusts pre-commit framework to manage hook configuration
- .pre-commit-config.yaml is the source of truth for what runs

For hook content validation:
- See .pre-commit-config.yaml (hooks with stages: [pre-push])
- Use `pre-commit run --hook-stage pre-push --all-files` to verify hooks

Fixes: KISS violation - removed over-engineered hook content validation
"""

import os
import re
import subprocess
import sys
from pathlib import Path


def get_repo_root() -> Path:
    """Get repository root directory."""
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True,
        timeout=60,
    )
    return Path(result.stdout.strip())


def get_hook_path(repo_root: Path) -> Path:
    """
    Get path to pre-push hook (worktree-safe).

    Uses `git rev-parse --git-common-dir` to handle both:
    - Main repository (.git is a directory)
    - Git worktrees (.git is a file pointing to common dir)
    """
    result = subprocess.run(
        ["git", "rev-parse", "--git-common-dir"],
        capture_output=True,
        text=True,
        check=True,
        timeout=60,
        cwd=repo_root,
    )
    git_common_dir = Path(result.stdout.strip())

    if not git_common_dir.is_absolute():
        git_common_dir = repo_root / git_common_dir

    return git_common_dir / "hooks" / "pre-push"


def is_pre_commit_managed(content: str) -> bool:
    """Check if hook is managed by pre-commit framework."""
    patterns = [
        r"File generated by pre-commit",
        r"pre_commit",
        r"--hook-type=pre-push",
    ]
    return any(re.search(pattern, content) for pattern in patterns)


def validate_hook() -> tuple[bool, list[str]]:
    """
    Validate pre-push hook is installed and managed by pre-commit.

    Returns:
        Tuple of (is_valid, error_messages)
    """
    errors = []
    repo_root = get_repo_root()
    hook_path = get_hook_path(repo_root)

    # Check 1: Hook exists
    if not hook_path.exists():
        errors.append("Pre-push hook not found.\nFix: pre-commit install --hook-type pre-push")
        return False, errors

    # Check 2: Hook is executable
    if not os.access(hook_path, os.X_OK):
        errors.append("Pre-push hook is not executable.\nFix: chmod +x .git/hooks/pre-push")

    # Check 3: Hook is managed by pre-commit
    with open(hook_path) as f:
        content = f.read()

    if not is_pre_commit_managed(content):
        errors.append("Pre-push hook is not managed by pre-commit framework.\nFix: pre-commit install --hook-type pre-push")

    return len(errors) == 0, errors


def main() -> int:
    """Main entry point."""
    # Skip in CI - CI runs pre-commit directly
    if os.environ.get("CI") == "true" or os.environ.get("GITHUB_ACTIONS") == "true":
        print("Skipped: CI runs pre-commit directly, not via git hooks")
        return 0

    try:
        is_valid, errors = validate_hook()

        if is_valid:
            print("Pre-push hook is installed and managed by pre-commit")
            return 0

        print("Pre-push hook validation failed:")
        for error in errors:
            print(f"  {error}")

        print("\nQuick fix:")
        print("  pre-commit install --hook-type pre-commit --hook-type pre-push")
        return 1

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
